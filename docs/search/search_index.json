{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Acai-TS","text":"<p>DRY, configurable, declarative TypeScript library for working with Amazon Web Service Lambdas.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Highly configurable APIGateway internal router with decorator support</li> <li>OpenAPI schema adherence for all event types</li> <li>Extensible and customizable middleware for validation and other tasks</li> <li>DRY coding interfaces without the need of boilerplate</li> <li>Full TypeScript support with comprehensive type definitions</li> <li>Decorator-based routing (@Route, @Validate, @Before, @After, etc.)</li> <li>Pattern-based routing (convention over configuration)</li> <li>Ease-of-use with the serverless framework</li> <li>Local development support</li> <li>Happy Path Programming (See Philosophy below)</li> </ul>"},{"location":"#philosophy","title":"Philosophy","text":"<p>The Acai-TS philosophy is to provide a DRY, configurable, declarative library for use with Amazon Lambdas, which encourages Happy Path Programming (HPP).</p> <p>Happy Path Programming is an idea in which inputs are all validated before operated on. This ensures code follows the happy path without the need for mid-level, nested exceptions and all the nasty exception handling that comes with that. The library uses layers of customizable middleware options to allow a developer to easily dictate what constitutes a valid input, without nested conditionals, try/catch blocks or other coding blocks which distract from the happy path that covers the majority of that code's intended operation.</p>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import 'reflect-metadata';\nimport { Router, Route, Validate, Response, Request } from 'acai-ts';\n\n@Route('POST', '/users')\n@Validate({\n  body: {\n    type: 'object',\n    required: ['name', 'email'],\n    properties: {\n      name: { type: 'string' },\n      email: { type: 'string', format: 'email' }\n    }\n  }\n})\nexport class CreateUserEndpoint {\n  async handler(request: Request, response: Response): Promise&lt;void&gt; {\n    // Body is already validated - focus on business logic!\n    response.setBody({\n      id: '123',\n      email: request.body.email,\n      name: request.body.name\n    });\n  }\n}\n</code></pre>"},{"location":"#typescript-first","title":"TypeScript First","text":"<p>Acai-TS is the TypeScript evolution of acai-js, built from the ground up with type safety and modern TypeScript features in mind.</p>"},{"location":"changes/","title":"Migration from acai-js","text":""},{"location":"changes/#migration-guide-acai-js-to-acai-ts","title":"Migration Guide: acai-js to acai-ts","text":"<p>Acai-TS is a complete TypeScript rewrite of acai-js with improved type safety, decorator support, and modern ES6+ features. This guide will help you migrate your existing acai-js code to acai-ts.</p> Quick Start <p>The main changes are:</p> <ol> <li>Install <code>acai-ts</code> and <code>reflect-metadata</code></li> <li>Convert JavaScript to TypeScript</li> <li>Update imports to use ES6 modules</li> <li>Add type annotations</li> <li>Use decorators for cleaner endpoint definitions (optional)</li> </ol>"},{"location":"changes/#installation-changes","title":"Installation Changes","text":""},{"location":"changes/#before-acai-js","title":"Before (acai-js)","text":"<pre><code>npm install acai-js\n</code></pre>"},{"location":"changes/#after-acai-ts","title":"After (acai-ts)","text":"<pre><code>npm install acai-ts reflect-metadata\n</code></pre> <p>New Requirements: - Node.js &gt;= 18.18.2 - TypeScript &gt;= 5.0 - <code>reflect-metadata</code> package (for decorator support)</p>"},{"location":"changes/#import-changes","title":"Import Changes","text":""},{"location":"changes/#before-acai-js_1","title":"Before (acai-js)","text":"<pre><code>const { Router, Event } = require('acai-js');\n</code></pre>"},{"location":"changes/#after-acai-ts_1","title":"After (acai-ts)","text":"<pre><code>import 'reflect-metadata';\nimport { Router, Event } from 'acai-ts';\nimport { APIGatewayProxyEvent, DynamoDBStreamEvent } from 'aws-lambda';\n</code></pre>"},{"location":"changes/#typescript-configuration","title":"TypeScript Configuration","text":"<p>Add to your <code>tsconfig.json</code>:</p> <pre><code>{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"target\": \"ES2020\",\n    \"module\": \"commonjs\",\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true\n  }\n}\n</code></pre>"},{"location":"changes/#apigateway-router-changes","title":"APIGateway Router Changes","text":""},{"location":"changes/#before-acai-js_2","title":"Before (acai-js)","text":"<pre><code>const { Router } = require('acai-js');\n\nexports.handler = async (event) =&gt; {\n  const router = new Router({\n    basePath: '/api/v1',\n    schemaPath: './openapi.yml'\n  });\n\n  return await router.route(event);\n};\n</code></pre>"},{"location":"changes/#after-acai-ts_2","title":"After (acai-ts)","text":"<pre><code>import 'reflect-metadata';\nimport { Router } from 'acai-ts';\nimport { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\n\nexport const handler = async (\n  event: APIGatewayProxyEvent\n): Promise&lt;APIGatewayProxyResult&gt; =&gt; {\n  const router = new Router({\n    basePath: '/api/v1',\n    schemaPath: './openapi.yml'\n  });\n\n  return await router.route(event);\n};\n</code></pre>"},{"location":"changes/#endpoint-changes","title":"Endpoint Changes","text":""},{"location":"changes/#pattern-based-file-based-routing","title":"Pattern-Based (File-Based) Routing","text":""},{"location":"changes/#before-acai-js_3","title":"Before (acai-js)","text":"<pre><code>// users.js\nexports.requirements = {\n  post: {\n    requiredBody: 'CreateUserRequest'\n  }\n};\n\nexports.post = async (request, response) =&gt; {\n  response.body = { id: '123', ...request.body };\n  return response;\n};\n</code></pre>"},{"location":"changes/#after-acai-ts_3","title":"After (acai-ts)","text":"<pre><code>// users.ts\nimport { RequestClient, ResponseClient, EndpointRequirements } from 'acai-ts';\n\nexport const requirements: EndpointRequirements = {\n  post: {\n    requiredBody: 'CreateUserRequest'\n  }\n};\n\nexport const post = async (\n  request: RequestClient, \n  response: ResponseClient\n): Promise&lt;ResponseClient&gt; =&gt; {\n  response.body = { id: '123', ...request.body };\n  return response;\n};\n</code></pre>"},{"location":"changes/#decorator-based-routing-new-in-acai-ts","title":"Decorator-Based Routing (NEW in acai-ts!)","text":"<pre><code>import { Endpoint, Route, Validate, Response, Request } from 'acai-ts';\n\n@Route('POST', '/users')\n@Validate('CreateUserRequest')\nexport class CreateUserEndpoint extends Endpoint {\n  async handler(request: Request, response: Response) {\n    response.body = { id: '123', ...request.body };\n    return response;\n  }\n}\n</code></pre>"},{"location":"changes/#event-handler-changes","title":"Event Handler Changes","text":""},{"location":"changes/#dynamodb-streams","title":"DynamoDB Streams","text":""},{"location":"changes/#before-acai-js_4","title":"Before (acai-js)","text":"<pre><code>const { Event } = require('acai-js');\n\nexports.handler = async (event) =&gt; {\n  const dynamodb = new Event(event, {\n    operations: ['INSERT', 'MODIFY']\n  });\n\n  for (const record of dynamodb.records) {\n    console.log(record.newImage);\n  }\n};\n</code></pre>"},{"location":"changes/#after-acai-ts_4","title":"After (acai-ts)","text":"<pre><code>import { Event } from 'acai-ts';\nimport { DynamoDBStreamEvent } from 'aws-lambda';\n\nexport const handler = async (event: DynamoDBStreamEvent): Promise&lt;void&gt; =&gt; {\n  const dynamodb = new Event(event, {\n    operations: ['INSERT', 'MODIFY']\n  });\n\n  for (const record of dynamodb.records) {\n    console.log(record.newImage);\n  }\n};\n</code></pre>"},{"location":"changes/#s3-events","title":"S3 Events","text":""},{"location":"changes/#before-acai-js_5","title":"Before (acai-js)","text":"<pre><code>const { Event } = require('acai-js');\n\nexports.handler = async (event) =&gt; {\n  const s3Event = new Event(event, {\n    getObject: true,\n    isJSON: true\n  });\n\n  await s3Event.process();\n\n  for (const record of s3Event.records) {\n    console.log(record.body);\n  }\n};\n</code></pre>"},{"location":"changes/#after-acai-ts_5","title":"After (acai-ts)","text":"<pre><code>import { Event } from 'acai-ts';\nimport { S3Event } from 'aws-lambda';\n\nexport const handler = async (event: S3Event): Promise&lt;void&gt; =&gt; {\n  const s3Event = new Event(event, {\n    getObject: true,\n    isJSON: true\n  });\n\n  await s3Event.process();\n\n  for (const record of s3Event.records) {\n    console.log(record.body);\n  }\n};\n</code></pre>"},{"location":"changes/#sqs-messages","title":"SQS Messages","text":""},{"location":"changes/#before-acai-js_6","title":"Before (acai-js)","text":"<pre><code>const { Event } = require('acai-js');\n\nexports.handler = async (event) =&gt; {\n  const sqsEvent = new Event(event);\n\n  for (const record of sqsEvent.records) {\n    console.log(record.body);\n  }\n};\n</code></pre>"},{"location":"changes/#after-acai-ts_6","title":"After (acai-ts)","text":"<pre><code>import { Event } from 'acai-ts';\nimport { SQSEvent } from 'aws-lambda';\n\nexport const handler = async (event: SQSEvent): Promise&lt;void&gt; =&gt; {\n  const sqsEvent = new Event(event);\n\n  for (const record of sqsEvent.records) {\n    console.log(record.body);\n  }\n};\n</code></pre>"},{"location":"changes/#logger-changes","title":"Logger Changes","text":""},{"location":"changes/#before-acai-js_7","title":"Before (acai-js)","text":"<pre><code>global.logger.info('message');\nglobal.logger.error('error');\n</code></pre>"},{"location":"changes/#after-acai-ts_7","title":"After (acai-ts)","text":"<pre><code>import { Logger } from 'acai-ts';\n\nLogger.info('message');\nLogger.error('error');\n</code></pre>"},{"location":"changes/#new-features-in-acai-ts","title":"New Features in acai-ts","text":""},{"location":"changes/#1-decorator-support","title":"1. Decorator Support","text":"<p>Use decorators for cleaner endpoint definitions:</p> <pre><code>@Route('POST', '/users')\n@Validate('CreateUserRequest')\n@Before(authMiddleware)\n@After(loggingMiddleware)\n@Timeout(30000)\nexport class CreateUserEndpoint extends Endpoint {\n  async handler(request: Request, response: Response) {\n    // Clean business logic\n  }\n}\n</code></pre>"},{"location":"changes/#2-full-typescript-type-safety","title":"2. Full TypeScript Type Safety","text":"<p>All classes, interfaces, and functions are fully typed:</p> <pre><code>import { RequestClient, ResponseClient } from 'acai-ts';\n\nconst request: RequestClient = {\n  path: '/users',\n  method: 'POST',\n  body: { email: 'user@example.com' },\n  headers: {},\n  queryParameters: {},\n  pathParameters: {}\n};\n</code></pre>"},{"location":"changes/#3-custom-data-classes-with-types","title":"3. Custom Data Classes with Types","text":"<pre><code>interface UserData {\n  id: string;\n  email: string;\n}\n\nclass User {\n  id: string;\n  email: string;\n\n  constructor(record: any) {\n    this.id = record.body.id;\n    this.email = record.body.email;\n  }\n\n  sendWelcomeEmail(): void {\n    // Type-safe method\n  }\n}\n\nconst dynamodb = new Event&lt;User&gt;(event, {\n  dataClass: User,\n  operations: ['INSERT']\n});\n\nfor (const user of dynamodb.records) {\n  user.sendWelcomeEmail(); // Fully typed!\n}\n</code></pre>"},{"location":"changes/#4-improved-error-handling","title":"4. Improved Error Handling","text":"<pre><code>import { ApiError } from 'acai-ts';\n\nthrow new ApiError('User not found', 404, 'user_id');\n</code></pre>"},{"location":"changes/#api-compatibility","title":"API Compatibility","text":"<p>Most APIs remain compatible, but with added type safety:</p> acai-js acai-ts Notes <code>Router</code> <code>Router</code> Same API, now typed <code>Event</code> <code>Event</code> Same API, now typed <code>Request</code> <code>RequestClient</code> / <code>Request</code> Typed interface <code>Response</code> <code>ResponseClient</code> / <code>Response</code> Typed interface <code>global.logger</code> <code>Logger</code> Import from package"},{"location":"changes/#breaking-changes","title":"Breaking Changes","text":""},{"location":"changes/#1-package-name","title":"1. Package Name","text":"<ul> <li>Old: <code>acai-js</code> or <code>@syngenta-digital/Acai</code></li> <li>New: <code>acai-ts</code></li> </ul>"},{"location":"changes/#2-nodejs-version","title":"2. Node.js Version","text":"<ul> <li>Old: Node 10.10+</li> <li>New: Node 18.18.2+</li> </ul>"},{"location":"changes/#3-file-extensions","title":"3. File Extensions","text":"<ul> <li>Old: <code>.js</code> files</li> <li>New: <code>.ts</code> files</li> </ul>"},{"location":"changes/#4-export-syntax","title":"4. Export Syntax","text":"<ul> <li>Old: <code>exports.handler</code></li> <li>New: <code>export const handler</code></li> </ul>"},{"location":"changes/#5-import-syntax","title":"5. Import Syntax","text":"<ul> <li>Old: <code>require()</code></li> <li>New: <code>import</code> statements</li> </ul>"},{"location":"changes/#migration-checklist","title":"Migration Checklist","text":"<ul> <li>[ ] Install <code>acai-ts</code> and <code>reflect-metadata</code></li> <li>[ ] Update <code>tsconfig.json</code> with decorator support</li> <li>[ ] Convert <code>.js</code> files to <code>.ts</code></li> <li>[ ] Change <code>require()</code> to <code>import</code> statements</li> <li>[ ] Change <code>exports.</code> to <code>export const</code></li> <li>[ ] Add AWS Lambda event types</li> <li>[ ] Add type annotations to functions</li> <li>[ ] Update <code>acai-js</code> imports to <code>acai-ts</code></li> <li>[ ] Add <code>import 'reflect-metadata'</code> at entry points</li> <li>[ ] Test all endpoints and event handlers</li> <li>[ ] Update deployment configuration for TypeScript build</li> </ul>"},{"location":"changes/#need-help","title":"Need Help?","text":"<ul> <li>GitHub Issues</li> <li>Examples Repository</li> <li>API Documentation</li> </ul>"},{"location":"demo/","title":"Demo &amp; Explanation of Acai-TS","text":""},{"location":"demo/#examples-repository","title":"Examples Repository","text":"<p>Don't like reading documentation? Check out our working examples:</p> Working Examples <p>All examples are located in the examples directory of this repository.</p> <ul> <li>APIGateway with Decorators - Full decorator-based routing example</li> <li>APIGateway with Pattern Routing - Convention over configuration example</li> <li>DynamoDB Streams - Process DynamoDB stream events</li> <li>S3 Events - Process S3 bucket events</li> <li>SQS Messages - Process SQS queue messages</li> </ul>"},{"location":"demo/#quick-start-tutorial","title":"Quick Start Tutorial","text":""},{"location":"demo/#1-install-acai-ts","title":"1. Install Acai-TS","text":"<pre><code>npm install acai-ts reflect-metadata\n</code></pre>"},{"location":"demo/#2-create-your-first-endpoint","title":"2. Create Your First Endpoint","text":"<pre><code>import 'reflect-metadata';\nimport { Router, Endpoint, Route, Response, Request } from 'acai-ts';\nimport { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\n\n@Route('GET', '/hello')\nexport class HelloEndpoint extends Endpoint {\n  async handler(request: Request, response: Response) {\n    response.body = { message: 'Hello, World!' };\n    return response;\n  }\n}\n\nexport const handler = async (\n  event: APIGatewayProxyEvent\n): Promise&lt;APIGatewayProxyResult&gt; =&gt; {\n  const router = new Router({\n    basePath: '/api/v1',\n    endpoints: [HelloEndpoint]\n  });\n\n  return await router.route(event);\n};\n</code></pre>"},{"location":"demo/#3-add-schema-validation","title":"3. Add Schema Validation","text":"<pre><code>@Route('POST', '/users')\n@Validate('CreateUserRequest')\nexport class CreateUserEndpoint extends Endpoint {\n  async handler(request: Request, response: Response) {\n    // request.body is already validated against your OpenAPI schema\n    response.body = { \n      id: '123',\n      ...request.body \n    };\n    return response;\n  }\n}\n</code></pre>"},{"location":"demo/#4-add-middleware","title":"4. Add Middleware","text":"<pre><code>const authMiddleware = async (request: Request) =&gt; {\n  if (!request.headers.authorization) {\n    throw new ApiError('Unauthorized', 401);\n  }\n};\n\n@Route('GET', '/profile')\n@Before(authMiddleware)\nexport class ProfileEndpoint extends Endpoint {\n  async handler(request: Request, response: Response) {\n    response.body = { user: 'profile data' };\n    return response;\n  }\n}\n</code></pre>"},{"location":"demo/#key-concepts","title":"Key Concepts","text":""},{"location":"demo/#happy-path-programming","title":"Happy Path Programming","text":"<p>Acai-TS embraces Happy Path Programming - validation happens upfront, so your business logic runs cleanly:</p> <pre><code>// \u274c Without Acai-TS: Defensive coding everywhere\nexport const handler = async (event: any) =&gt; {\n  try {\n    if (!event.body) throw new Error('No body');\n    const body = JSON.parse(event.body);\n    if (!body.email) throw new Error('Email required');\n    // Finally, business logic...\n  } catch (error) {\n    return { statusCode: 400, body: JSON.stringify({ error }) };\n  }\n};\n\n// \u2705 With Acai-TS: Validation handled, focus on logic\n@Route('POST', '/users')\n@Validate('CreateUserRequest')\nexport class CreateUserEndpoint extends Endpoint {\n  async handler(request: Request, response: Response) {\n    // Body is already validated - just write business logic!\n    const user = await this.userService.create(request.body);\n    response.body = user;\n    return response;\n  }\n}\n</code></pre>"},{"location":"demo/#typescript-first","title":"TypeScript First","text":"<p>Full type safety throughout:</p> <pre><code>interface User {\n  id: string;\n  email: string;\n  name: string;\n}\n\n@Route('GET', '/users/{id}')\nexport class GetUserEndpoint extends Endpoint {\n  async handler(request: Request, response: Response) {\n    const userId: string = request.pathParameters.id;\n    const user: User = await this.userRepo.findById(userId);\n\n    response.body = user; // Fully typed!\n    return response;\n  }\n}\n</code></pre>"},{"location":"demo/#next-steps","title":"Next Steps","text":"<ul> <li>APIGateway Documentation - Learn about routing, decorators, and request/response handling</li> <li>DynamoDB Events - Process DynamoDB stream events</li> <li>S3 Events - Process S3 bucket events  </li> <li>SQS Events - Process SQS queue messages</li> </ul>"},{"location":"install/","title":"Install","text":""},{"location":"install/#requirements","title":"Requirements","text":"<ul> <li>Node.js 18.18.2 or higher; download and install Node.js</li> <li>TypeScript 5.0 or higher</li> <li>Access to public npm registry</li> </ul>"},{"location":"install/#installation","title":"Installation","text":"npm <pre><code>npm install acai-ts reflect-metadata\n</code></pre> yarn <pre><code>yarn add acai-ts reflect-metadata\n</code></pre> pnpm <pre><code>pnpm add acai-ts reflect-metadata\n</code></pre>"},{"location":"install/#typescript-configuration","title":"TypeScript Configuration","text":"<p>Acai-TS requires the following TypeScript compiler options in your <code>tsconfig.json</code>:</p> <pre><code>{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"target\": \"ES2020\",\n    \"module\": \"commonjs\",\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true\n  }\n}\n</code></pre>"},{"location":"install/#import-reflect-metadata","title":"Import Reflect Metadata","text":"<p>You must import <code>reflect-metadata</code> at the entry point of your application:</p> <pre><code>import 'reflect-metadata';\nimport { Router, Endpoint } from 'acai-ts';\n\n// Your code here...\n</code></pre>"},{"location":"install/#verify-installation","title":"Verify Installation","text":"<p>Create a simple test file to verify the installation:</p> <pre><code>import 'reflect-metadata';\nimport { Router } from 'acai-ts';\n\nconst router = new Router({\n  basePath: '/api/v1'\n});\n\nconsole.log('Acai-TS installed successfully!');\n</code></pre>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>This guide covers common issues you may encounter when using acai-ts and their solutions.</p>"},{"location":"troubleshooting/#route-resolution-issues","title":"Route Resolution Issues","text":""},{"location":"troubleshooting/#routepath-differences-between-development-and-build","title":"routePath Differences Between Development and Build","text":"<p>Problem: Routes work in development but fail in production builds, or vice versa.</p> <p>Symptoms: - Routes return 404 errors in production - Path parameters are not correctly parsed - Route matching behaves differently between local development and deployed environments</p> <p>Causes: - File path resolution differences between development and compiled code - TypeScript compilation changing file structure - Serverless packaging affecting route discovery</p> <p>Solutions:</p>"},{"location":"troubleshooting/#1-use-absolute-paths-in-router-configuration","title":"1. Use Absolute Paths in Router Configuration","text":"<pre><code>// \u274c Problematic - relative paths\nconst router = new Router({\n  mode: 'directory',\n  routesPath: './api/handlers'\n});\n\n// \u2705 Better - absolute paths from project root\nconst router = new Router({\n  mode: 'directory',\n  routesPath: path.join(__dirname, '../api/handlers')\n});\n</code></pre>"},{"location":"troubleshooting/#2-verify-build-output-structure","title":"2. Verify Build Output Structure","text":"<p>Check that your build process preserves the expected file structure:</p> <pre><code># Check your dist/build directory structure\nfind dist -name \"*.js\" -type f | head -10\n\n# Ensure route files are in expected locations\nls -la dist/api/handlers/\n</code></pre>"},{"location":"troubleshooting/#3-use-explicit-route-lists-for-production","title":"3. Use Explicit Route Lists for Production","text":"<p>For maximum reliability in production:</p> <pre><code>const router = new Router({\n  mode: 'list',\n  routes: [\n    { method: 'GET', path: '/users', handler: 'dist/api/handlers/users.js' },\n    { method: 'POST', path: '/users', handler: 'dist/api/handlers/users.js' },\n    { method: 'GET', path: '/users/:id', handler: 'dist/api/handlers/users/[id].js' }\n  ]\n});\n</code></pre>"},{"location":"troubleshooting/#4-environment-specific-configuration","title":"4. Environment-Specific Configuration","text":"<pre><code>const isDevelopment = process.env.NODE_ENV === 'development';\n\nconst router = new Router({\n  mode: 'directory',\n  routesPath: isDevelopment \n    ? 'src/api/handlers'\n    : path.join(__dirname, 'api/handlers'),\n  basePath: isDevelopment ? '' : '/api/v1'\n});\n</code></pre>"},{"location":"troubleshooting/#5-debug-route-discovery","title":"5. Debug Route Discovery","text":"<p>Enable logging to see which routes are being discovered:</p> <pre><code>const router = new Router({\n  mode: 'pattern',\n  routesPath: 'api/**/*.js',\n  outputError: true, // Enable error output\n  globalLogger: true // Enable detailed logging\n});\n\n// Add custom logging\nrouter.autoLoad();\nconsole.log('Discovered routes:', router.getRoutes?.());\n</code></pre>"},{"location":"troubleshooting/#decorator-issues","title":"Decorator Issues","text":""},{"location":"troubleshooting/#reflect-metadata-not-found","title":"Reflect Metadata Not Found","text":"<p>Problem: <code>Cannot read property 'getMetadata' of undefined</code> or similar metadata errors.</p> <p>Solution: <pre><code>// \u2705 Must be imported FIRST, before any decorators\nimport 'reflect-metadata';\nimport { Route, Validate } from 'acai-ts';\n\n// Rest of your code...\n</code></pre></p>"},{"location":"troubleshooting/#typescript-configuration-issues","title":"TypeScript Configuration Issues","text":"<p>Problem: Decorators not working or compiler errors.</p> <p>Solution: Ensure your <code>tsconfig.json</code> has the correct settings:</p> <pre><code>{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"target\": \"ES2020\",\n    \"module\": \"commonjs\",\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"strict\": true\n  }\n}\n</code></pre>"},{"location":"troubleshooting/#decorator-order-issues","title":"Decorator Order Issues","text":"<p>Problem: Middleware not executing in expected order.</p> <p>Solution: Understand the execution order:</p> <pre><code>export class UserController {\n  // Execution order:\n  @Route('POST', '/users')    // 1. Route definition\n  @Auth(authFunction)         // 2. Authentication (executed first)\n  @Validate(schema)           // 3. Validation (executed second)\n  @Before(beforeMiddleware)   // 4. Before middleware (executed third)\n  @After(afterMiddleware)     // 6. After middleware (executed after handler)\n  @Timeout(5000)              // Applied throughout entire request\n  async createUser(...) {     // 5. Handler function\n    // Your code here\n  }\n}\n</code></pre>"},{"location":"troubleshooting/#method-not-found-errors","title":"Method Not Found Errors","text":"<p>Problem: <code>Method not found</code> or handler not being called.</p> <p>Common Causes &amp; Solutions:</p>"},{"location":"troubleshooting/#1-method-name-mismatch","title":"1. Method Name Mismatch","text":"<pre><code>// \u274c Wrong - method name doesn't match decorator\n@Route('POST', '/users')\nasync getUser() {} // Method name suggests GET but decorator says POST\n\n// \u2705 Correct - clear method names\n@Route('POST', '/users')\nasync createUser() {}\n\n@Route('GET', '/users/:id')\nasync getUser() {}\n</code></pre>"},{"location":"troubleshooting/#2-missing-export","title":"2. Missing Export","text":"<pre><code>// \u274c Wrong - not exported\n@Route('GET', '/users')\nasync getUsers() {}\n\n// \u2705 Correct - properly exported\nexport class UserController {\n  @Route('GET', '/users')\n  async getUsers() {}\n}\n</code></pre>"},{"location":"troubleshooting/#3-router-not-recognizing-decorated-routes","title":"3. Router Not Recognizing Decorated Routes","text":"<pre><code>// Make sure your router is configured correctly for decorators\nconst router = new Router({\n  mode: 'list',\n  routes: [], // Empty array - routes come from decorators\n  // ... other config\n});\n\n// And that you're importing decorated classes somewhere\nimport './controllers/UserController'; // This registers the decorated routes\n</code></pre>"},{"location":"troubleshooting/#validation-issues","title":"Validation Issues","text":""},{"location":"troubleshooting/#schema-validation-failures","title":"Schema Validation Failures","text":"<p>Problem: Valid requests are being rejected or invalid requests are passing.</p> <p>Debug Steps:</p> <ol> <li> <p>Check Schema Syntax: <pre><code>// \u2705 Correct JSON Schema\n@Validate({\n  body: {\n    type: 'object',\n    required: ['name', 'email'],\n    properties: {\n      name: { type: 'string', minLength: 1 },\n      email: { type: 'string', format: 'email' }\n    }\n  }\n})\n\n// \u274c Common mistake - wrong schema structure\n@Validate({\n  name: { type: 'string' }, // Missing 'body' wrapper\n  email: { type: 'string' }\n})\n</code></pre></p> </li> <li> <p>Enable Validation Logging: <pre><code>const router = new Router({\n  // ... other config\n  outputError: true, // Show detailed validation errors\n  validateResponse: true // Also validate responses\n});\n</code></pre></p> </li> <li> <p>Test Schema Separately: <pre><code>import { Validator } from 'acai-ts';\n\nconst validator = new Validator();\nconst schema = { /* your schema */ };\nconst data = { /* your test data */ };\n\nconst result = validator.validate(data, schema);\nconsole.log('Validation result:', result);\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#openapi-validation-issues","title":"OpenAPI Validation Issues","text":"<p>Problem: Router with <code>autoValidate: true</code> not working correctly.</p> <p>Solution: <pre><code>const router = new Router({\n  mode: 'directory',\n  routesPath: 'api/handlers',\n  autoValidate: true,\n  schemaPath: './openapi.yml', // Make sure this path is correct\n  validateResponse: false // Set to true only if you have response schemas\n});\n</code></pre></p> <p>Verify your OpenAPI schema: - Paths match your route structure exactly - HTTP methods are correctly defined - Request/response schemas are valid JSON Schema</p>"},{"location":"troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"troubleshooting/#slow-route-resolution","title":"Slow Route Resolution","text":"<p>Problem: First request takes a long time or timeouts occur.</p> <p>Solutions:</p> <ol> <li> <p>Use <code>autoLoad()</code> for Better Cold Start Performance: <pre><code>const router = new Router({\n  mode: 'directory',\n  routesPath: 'api/handlers'\n});\n\n// Pre-load routes during Lambda initialization\nrouter.autoLoad();\n\nexport const handler = async (event) =&gt; {\n  return router.route(event);\n};\n</code></pre></p> </li> <li> <p>Optimize File Discovery: <pre><code>// \u2705 Specific patterns perform better\nconst router = new Router({\n  mode: 'pattern',\n  routesPath: 'api/handlers/**/*.controller.js' // Specific pattern\n});\n\n// \u274c Avoid overly broad patterns\nconst router = new Router({\n  mode: 'pattern',\n  routesPath: '**/*.js' // Too broad, scans entire project\n});\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#memory-issues-with-large-applications","title":"Memory Issues with Large Applications","text":"<p>Problem: High memory usage or out-of-memory errors.</p> <p>Solutions:</p> <ol> <li> <p>Use Targeted Route Loading: <pre><code>// Instead of loading all routes, be selective\nconst router = new Router({\n  mode: 'list',\n  routes: [\n    // Only include routes you actually need\n    { method: 'GET', path: '/users', handler: 'handlers/users.js' }\n  ]\n});\n</code></pre></p> </li> <li> <p>Avoid Loading Heavy Dependencies in Route Files: <pre><code>// \u274c Heavy imports loaded for all routes\nimport * as AWS from 'aws-sdk';\nimport * as heavyLibrary from 'heavy-library';\n\n@Route('GET', '/users')\nasync getUsers() {\n  // Simple handler that doesn't need heavy libraries\n}\n\n// \u2705 Lazy load heavy dependencies\n@Route('POST', '/process-data')\nasync processData() {\n  const AWS = await import('aws-sdk'); // Lazy load when needed\n  const processor = await import('./heavy-processor');\n  // Use as needed\n}\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#authentication-issues","title":"Authentication Issues","text":""},{"location":"troubleshooting/#auth-not-blocking-requests","title":"@Auth Not Blocking Requests","text":"<p>Problem: Authentication decorator allows unauthorized requests through.</p> <p>Common Causes:</p> <ol> <li> <p>Auth Function Not Returning Boolean: <pre><code>// \u274c Wrong - doesn't return boolean\n@Auth(async (request) =&gt; {\n  const user = await validateUser(request);\n  // Missing return statement!\n})\n\n// \u2705 Correct - explicitly returns boolean\n@Auth(async (request) =&gt; {\n  const user = await validateUser(request);\n  return user !== null; // Explicit boolean return\n})\n</code></pre></p> </li> <li> <p>Async Issues: <pre><code>// \u274c Wrong - not awaiting async operations\n@Auth((request) =&gt; {\n  return validateUser(request); // Returns Promise, not boolean!\n})\n\n// \u2705 Correct - properly handling async\n@Auth(async (request) =&gt; {\n  const isValid = await validateUser(request);\n  return isValid;\n})\n</code></pre></p> </li> <li> <p>Exception Handling: <pre><code>// \u2705 Good practice - handle exceptions properly\n@Auth(async (request) =&gt; {\n  try {\n    const user = await validateUser(request);\n    return user !== null;\n  } catch (error) {\n    console.error('Auth error:', error);\n    return false; // Fail closed - deny access on error\n  }\n})\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#build-and-deployment-issues","title":"Build and Deployment Issues","text":""},{"location":"troubleshooting/#routes-not-found-after-deployment","title":"Routes Not Found After Deployment","text":"<p>Problem: Routes work locally but return 404 in deployed environment.</p> <p>Solutions:</p> <ol> <li> <p>Check Build Output: <pre><code># Verify your build includes route files\nnpm run build\nfind dist -name \"*.js\" | grep -E \"(route|handler|controller)\"\n</code></pre></p> </li> <li> <p>Verify Serverless Configuration: <pre><code># serverless.yml\nfunctions:\n  api:\n    handler: dist/handler.route  # Make sure path is correct\n    events:\n      - httpApi:\n          path: /{proxy+}\n          method: any\n</code></pre></p> </li> <li> <p>Check File Extensions in Production: <pre><code>// Use correct file extensions for your build output\nconst router = new Router({\n  mode: 'pattern',\n  routesPath: process.env.NODE_ENV === 'production'\n    ? 'dist/**/*.js'    // Built files\n    : 'src/**/*.ts'     // Source files\n});\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#timeout-issues","title":"Timeout Issues","text":"<p>Problem: Functions timing out unexpectedly.</p> <p>Debug Steps:</p> <ol> <li> <p>Check Timeout Configuration: <pre><code>// Function-level timeout\n@Timeout(30000) // 30 seconds\n\n// Router-level default\nconst router = new Router({\n  timeout: 30000 // 30 seconds default\n});\n</code></pre></p> </li> <li> <p>Add Logging to Identify Bottlenecks: <pre><code>@Before(async (request) =&gt; {\n  console.log('Request started:', Date.now());\n})\n\n@After(async (request, response) =&gt; {\n  console.log('Request completed:', Date.now());\n})\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you continue to experience issues:</p> <ol> <li> <p>Enable Debug Logging: <pre><code>const router = new Router({\n  globalLogger: true,\n  outputError: true\n});\n</code></pre></p> </li> <li> <p>Check Examples: Review the working examples</p> </li> <li> <p>Create Minimal Reproduction: Strip down to the simplest possible case that demonstrates the issue</p> </li> <li> <p>Check Version Compatibility: Ensure you're using compatible versions of acai-ts, TypeScript, and Node.js</p> </li> </ol> <p>For additional support, please check: - GitHub Issues - NPM Package - Documentation Examples</p>"},{"location":"apigateway/","title":"APIGateway","text":"<p>Event handler for Amazon APIGateway REST &amp; GraphQL.</p>"},{"location":"apigateway/#features","title":"Features","text":"<ul> <li>Configurable router based on 3 common routing patterns</li> <li>Built-in request validation using standard OpenAPI schema</li> <li>Easily validate request in modular and declarative way without any additional code</li> <li>Able to easily extend with custom middleware at both app and per-endpoint levels</li> <li>Support for CORS, binary and Gzip compression</li> <li>Full TypeScript support with type definitions</li> <li>Decorator-based routing with @Route, @Validate, @Before, @After, @Timeout, and @Auth</li> </ul>"},{"location":"apigateway/request/","title":"Request Object","text":"<p>By default, every endpoint function will receive an instance of the <code>RequestClient</code> class (aka <code>request</code>) as the first argument of their function. This <code>request</code> has a lot of properties which will do common things automatically, but still allows the developer to override those operations if they deem necessary. Below is a list and examples of all the properties of the <code>request</code>:</p> Example <p>Don't like reading documentation? Then look at our examples which can run locally!</p>"},{"location":"apigateway/request/#request-properties","title":"Request Properties","text":"property type mutable description <code>method</code> string no the http method of the request <code>resource</code> string no the AWS resource being invoked <code>authorizer</code> object no if using a customized authorizer, the authorizer object <code>headers</code> object no the headers of the request <code>params</code> object no combination of query string and path params in one object <code>queryParams</code> object no query string parameters from the request <code>pathParams</code> object no the path parameters of the request <code>route</code> string no the requested route with placeholders of params <code>path</code> string no the raw requested path with actual param values <code>json</code> object no the body of the request, converted from json string in object <code>xml</code> object no the body of the request, converted from xml string in object <code>graphql</code> string no the body of the graphql request as a string <code>body</code> any no the body of the request, converted to based on data type <code>raw</code> any no the raw body of the request no conversion <code>context</code> object yes mutable request context to assigned and pass around <code>event</code> object no the full event originally coming from the lambda"},{"location":"apigateway/request/#requestmethod","title":"<code>request.method</code>","text":"<pre><code>console.log(request.method);\n\n// example output:\n'get'\n</code></pre>"},{"location":"apigateway/request/#requestresource","title":"<code>request.resource</code>","text":"<pre><code>console.log(request.resource);\n\n// example output:\n'/{proxy+}'\n</code></pre>"},{"location":"apigateway/request/#requestauthorizer","title":"<code>request.authorizer</code>","text":"Tip <p>This is only useful if you are using an external authorizer with your lambda.</p> <pre><code>console.log(request.authorizer);\n\n// example output:\n{\n    apiKey: 'SOME KEY',\n    userId: 'x-1-3-4',\n    correlationId: 'abc12312',\n    principalId: '9de3f415a97e410386dbef146e88744e',\n    integrationLatency: 572\n}\n</code></pre>"},{"location":"apigateway/request/#requestheaders","title":"<code>request.headers</code>","text":"<pre><code>console.log(request.headers);\n\n// example output:\n{\n    'x-api-key': 'SOME-KEY',\n    'content-type': 'application/json'\n}\n</code></pre>"},{"location":"apigateway/request/#requestparams","title":"<code>request.params</code>","text":"Info <p>This combines both path parameters and query string parameters, nested in one object.</p> <pre><code>console.log(request.params);\n\n// example output:\n{\n    query: {\n        name: 'me'\n    },\n    path: {\n        id: 1\n    }\n}\n</code></pre>"},{"location":"apigateway/request/#requestqueryparams","title":"<code>request.queryParams</code>","text":"<pre><code>console.log(request.queryParams);\n\n// example output:\n{\n     name: 'me'\n}\n</code></pre>"},{"location":"apigateway/request/#requestpathparams","title":"<code>request.pathParams</code>","text":"<pre><code>console.log(request.pathParams);\n\n// example output:\n{\n     id: 1\n}\n</code></pre>"},{"location":"apigateway/request/#requestroute","title":"<code>request.route</code>","text":"Info <p>This will provide the route with the path param variables included</p> <pre><code>console.log(request.route);\n\n// example output:\n'grower/{id}'\n</code></pre>"},{"location":"apigateway/request/#requestpath","title":"<code>request.path</code>","text":"Info <p>This will provide the route with the path param values replacing the variables</p> <pre><code>console.log(request.path);\n\n// example output:\n'grower/1'\n</code></pre>"},{"location":"apigateway/request/#requestjson","title":"<code>request.json</code>","text":"Warning <p>This will raise an unhandled exception if the body is not json compatible</p> <pre><code>console.log(request.json);\n\n// example output:\n{\n    someJsonKey: 'someJsonValue'\n}\n</code></pre>"},{"location":"apigateway/request/#requestxml","title":"<code>request.xml</code>","text":"Warning <p>This will raise an unhandled exception if the body is not xml compatible</p> <pre><code>console.log(request.xml);\n\n// example output:\n{\n    someXMLKey: 'someXMLValue'\n}\n</code></pre>"},{"location":"apigateway/request/#requestgraphql","title":"<code>request.graphql</code>","text":"Info <p>This is graphql string since there is no object equivalent; you can pass this directly to your graphql resolver</p> <pre><code>console.log(request.graphql);\n\n// example output:\n'{\n    players {\n        name\n    }\n}'\n</code></pre>"},{"location":"apigateway/request/#requestbody","title":"<code>request.body</code>","text":"Tip <p>This is the safest way to get the body of the request. It will use the <code>content-type</code> header to determine the data sent and convert it; if the data can't be converted for whatever reason it will catch the error and return the raw body provided unconverted.</p> <pre><code>console.log(request.body);\n\n// example output:\n{\n    someXMLKey: 'someXMLValue'\n}\n</code></pre>"},{"location":"apigateway/request/#requestraw","title":"<code>request.raw</code>","text":"<pre><code>console.log(request.raw);\n\n// example output: whatever the raw data of the body is; string, json string, xml, binary, etc\n</code></pre>"},{"location":"apigateway/request/#requestcontext","title":"<code>request.context</code>","text":"Tip <p>This is the only mutable property of the request, to be used by any of the <code>before</code> or <code>beforeAll</code> middleware options</p> <pre><code>request.context = {application_assignable: true}\nconsole.log(request.context);\n\n// example output:\n{\n    application_assignable: true\n}\n</code></pre>"},{"location":"apigateway/request/#requestevent","title":"<code>request.event</code>","text":"Warning <p>This is the original full request. Not advisable to use this as defeats the purpose of the entire Acai. In addition, you don't want to mutate this object and potentially mess up the entire router.</p> <pre><code>import { APIGatewayProxyEventV2 } from 'aws-lambda';\n\nconsole.log(request.event);\n\n// example output:\n{\n    \"version\": \"2.0\",\n    \"routeKey\": \"$default\",\n    \"rawPath\": \"/my/path\",\n    \"rawQueryString\": \"parameter1=value1&amp;parameter1=value2&amp;parameter2=value\",\n    \"cookies\": [\n        \"cookie1\",\n        \"cookie2\"\n    ],\n    \"headers\": {\n        \"header1\": \"value1\",\n        \"header2\": \"value1,value2\"\n    },\n    \"queryStringParameters\": {\n        \"parameter1\": \"value1,value2\",\n        \"parameter2\": \"value\"\n    },\n    \"requestContext\": {\n        \"accountId\": \"123456789012\",\n        \"apiId\": \"api-id\",\n        \"authentication\": {\n            \"clientCert\": {\n                \"clientCertPem\": \"CERT_CONTENT\",\n                \"subjectDN\": \"www.example.com\",\n                \"issuerDN\": \"Example issuer\",\n                \"serialNumber\": \"a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1\",\n                \"validity\": {\n                    \"notBefore\": \"May 28 12:30:02 2019 GMT\",\n                    \"notAfter\": \"Aug  5 09:36:04 2021 GMT\"\n                }\n            }\n        },\n        \"authorizer\": {\n            \"jwt\": {\n                \"claims\": {\n                    \"claim1\": \"value1\",\n                    \"claim2\": \"value2\"\n                },\n                \"scopes\": [\n                    \"scope1\",\n                    \"scope2\"\n                ]\n            }\n        },\n        \"domainName\": \"id.execute-api.us-east-1.amazonaws.com\",\n        \"domainPrefix\": \"id\",\n        \"http\": {\n            \"method\": \"POST\",\n            \"path\": \"/my/path\",\n            \"protocol\": \"HTTP/1.1\",\n            \"sourceIp\": \"IP\",\n            \"userAgent\": \"agent\"\n        },\n        \"requestId\": \"id\",\n        \"routeKey\": \"$default\",\n        \"stage\": \"$default\",\n        \"time\": \"12/Mar/2020:19:03:58 +0000\",\n        \"timeEpoch\": 1583348638390\n    },\n    \"body\": \"Hello from Lambda\",\n    \"pathParameters\": {\n        \"parameter1\": \"value1\"\n    },\n    \"isBase64Encoded\": false,\n    \"stageVariables\": {\n        \"stageVariable1\": \"value1\",\n        \"stageVariable2\": \"value2\"\n    }\n}\n</code></pre>"},{"location":"apigateway/response/","title":"Response Object","text":"<p>By default, every endpoint function will receive an instance of the <code>ResponseClient</code> class (aka <code>response</code>) as the second argument of their function. This response object is meant to provide consistency to HTTP response codes and error signatures. Below is a list and examples of all the properties of the <code>response</code>:</p> Example <p>Don't like reading documentation? Then look at our examples which can run locally!</p>"},{"location":"apigateway/response/#response-properties","title":"Response Properties","text":"property type description <code>headers</code> object provide headers in key/value pairs to add new headers <code>code</code> number http response code to be returned the requester <code>body</code> any body of the response automatically converted to JSON string <code>rawBody</code> any body of the response not converted to JSON string <code>compress</code> boolean will compress the body if set to true and add proper headers <code>setError</code> func function to set an error with a key and value <code>hasError</code> boolean simple property to check if response already has errors in it"},{"location":"apigateway/response/#responseheaders","title":"<code>response.headers</code>","text":"<pre><code>response.headers = {key: 'status', value: 'ok'};\nresponse.headers = {key: 'response_id', value: 'some-guid'};\n\nconsole.log(response.headers);\n\n// example output:\n{\n    status: 'ok',\n    response_id: 'some-guid',\n}\n</code></pre>"},{"location":"apigateway/response/#responsecode","title":"<code>response.code</code>","text":"<pre><code>response.code = 418;\n\nconsole.log(response.code);\n\n// example output:\n418\n</code></pre>"},{"location":"apigateway/response/#responsebody","title":"<code>response.body</code>","text":"Info <p>This will automatically convert the body to json if possible when called.</p> <pre><code>response.body = {someKey: 'someValue'};\n\nconsole.log(response.body);\n\n// example output:\n'{\"someKey\":\"someValue\"}'\n</code></pre>"},{"location":"apigateway/response/#responserawbody","title":"<code>response.rawBody</code>","text":"Info <p>This will NOT automatically convert the body to json if possible when called. This is great when working with an <code>afterAll</code> method that wants to mutate the body of the response before returning to the user.</p> <pre><code>response.rawBody = {someKey: 'someValue'};\n\nconsole.log(response.rawBody);\n\n// example output:\n{\n    someKey: 'someValue'\n}\n</code></pre>"},{"location":"apigateway/response/#responsecompress","title":"<code>response.compress</code>","text":"Info <p>This will compress whatever is in the body property.</p> <pre><code>response.compress = true;\n\nconsole.log(response.body);\n// example output: this will gzip and compress the body.\n</code></pre>"},{"location":"apigateway/response/#responseseterrorkey-value","title":"<code>response.setError(key, value)</code>","text":"<pre><code>const someKey: string = 'abc123';\nresponse.setError('someKey', `${someKey} is not a valid key to use with this service; try again with a different key`);\nconst anotherKey: string = 'def456';\nresponse.setError('anotherKey', `${anotherKey} is not the correct type to operate on`);\n\nconsole.log(response.rawBody);\n\n// example output:\n{\n    errors: [\n        {\n            key_path: 'someKey',\n            message: 'abc123 is not a valid key to use with this service; try again with a different key'\n        },\n        {\n            key_path: 'anotherKey',\n            message: 'def456 is not the correct type to operate on'\n        }\n    ]\n}\n</code></pre>"},{"location":"apigateway/response/#responsehaserror","title":"<code>response.hasError</code>","text":"<pre><code>response.setError('user', `your access is denied`);\nconsole.log(response.hasError);\n\n// example output:\ntrue\n\n\nresponse.body = {user: 'you have been granted access'};\nconsole.log(response.hasError);\n\n// example output:\nfalse\n</code></pre>"},{"location":"apigateway/endpoint/configurations/","title":"Endpoint Configurations","text":"<p>In order to encourage \"Happy Path Programming\" and make it easier for developers to validate request fully, the Acai comes with a host of built-in validations as well as the ability to extend with custom validations and middleware. See the full validation list here:</p> Examples <p>Don't like reading documentation? Then look at our examples, which can run locally!</p>"},{"location":"apigateway/endpoint/configurations/#validation-configurations","title":"Validation Configurations","text":"requirement type description <code>requiredHeaders</code> array every header in this array must be in the headers of request <code>availableHeaders</code> array only headers in this array will be allowed in the request <code>requiredQuery</code> array every item in the array is a required query string parameter <code>availableQuery</code> array only items in this array are allowed in the request <code>requiredPath</code> string when using parameters, this is the required parameters <code>requiredBody</code> string references a JSschema component in your <code>schemaFile</code> <code>requiredResposne</code> string references a JSschema component in your <code>schemaFile</code> <code>requiredAuth</code> boolean will trigger <code>withAuth</code> function defined in the router config <code>before</code> function a custom function to be ran before your method function <code>after</code> function a custom function to be ran after your method function <code>dataClass</code> class a custom class that will be passed instead of the request obj <code>timeout</code> number a timeout value in microseconds to stop endpoint from running [<code>custom-requirement</code>] any see bottom of page"},{"location":"apigateway/endpoint/configurations/#requiredheaders","title":"<code>requiredHeaders</code>","text":"Info <p>Headers are case-sensitive, make sure your casing matches your expectations.</p> <pre><code>import { EndpointRequirements } from '@syngenta-digital/acai-ts';\n\nexport const requirements: EndpointRequirements = {\n    post: {\n        requiredHeaders: ['x-onbehalf-of']\n    }\n};\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#availableheaders","title":"<code>availableHeaders</code>","text":"Warning <p>This is not recommended for frequent use as it raises errors for every header which does not conform to the array provided. Many browsers, http tools, and libraries will automatically add headers to request, unbeknownst to the user. By using this setting, you will force every user of the endpoint to take extra care with the headers provided and may result in poor API consumer experience.</p> <pre><code>import { EndpointRequirements } from '@syngenta-digital/acai-ts';\n\nexport const requirements: EndpointRequirements = {\n    post: {\n        availableHeaders: ['x-onbehalf-of']\n    }\n};\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#requiredquery","title":"<code>requiredQuery</code>","text":"<pre><code>import { EndpointRequirements } from '@syngenta-digital/acai-ts';\n\nexport const requirements: EndpointRequirements = {\n    get: {\n        requiredQuery: ['requester_id']\n    }\n};\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#availablequery","title":"<code>availableQuery</code>","text":"<pre><code>import { EndpointRequirements } from '@syngenta-digital/acai-ts';\n\nexport const requirements: EndpointRequirements = {\n    get: {\n        availableQuery: ['grower_email', 'grower_phone', 'grower_first', 'grower_last'],\n    }\n};\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#requiredpath","title":"<code>requiredPath</code>","text":"Warning <p>This is required if you are using dynamic routing (ex. <code>{id}.ts</code>) with path parameters. The router will provide a path values in <code>request.pathParams</code></p> <pre><code>import { EndpointRequirements } from '@syngenta-digital/acai-ts';\n\nexport const requirements: EndpointRequirements = {\n    put: {\n        requiredPath: 'grower/{id}'\n    }\n};\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#requiredbody","title":"<code>requiredBody</code>","text":"Info <p>This is referencing a <code>components.schemas</code> section of your openapi.yml file defined in the <code>schemaFile</code> value in your router config.</p> <pre><code>import { EndpointRequirements } from '@syngenta-digital/acai-ts';\n\nexport const requirements: EndpointRequirements = {\n    post: {\n        requiredBody: 'post-grower-request'\n    }\n};\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#requiredresponse","title":"<code>requiredResponse</code>","text":"Info <p>This is referencing a <code>components.schemas</code> section of your openapi.yml file defined in the <code>schemaFile</code> value in your router config.</p> <pre><code>import { EndpointRequirements } from '@syngenta-digital/acai-ts';\n\nexport const requirements: EndpointRequirements = {\n    post: {\n        requiredResponse: 'post-grower-response'\n    }\n};\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#requiredauth","title":"<code>requiredAuth</code>","text":"Info <p>This will trigger the function you provided in the router config under the <code>withAuth</code> configuration</p> <pre><code>import { EndpointRequirements } from '@syngenta-digital/acai-ts';\n\nexport const requirements: EndpointRequirements = {\n    post:{\n        requiredAuth: true\n    }\n};\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#before","title":"<code>before</code>","text":"<pre><code>import { EndpointRequirements, RequestClient, ResponseClient } from '@syngenta-digital/acai-ts';\nimport * as db from 'api/logic/database';\n\nexport const requirements: EndpointRequirements = {\n    patch: {\n        before: async (request: RequestClient, response: ResponseClient, requirements: any): Promise&lt;void&gt; =&gt; {\n            const result = await db.checkGrowerIdExists(request.pathParams.id);\n            if (!result){\n                response.setError('grower/{id}', `grower with id: ${request.pathParams.id} does not exist.`);\n            }\n        }\n    }\n};\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#after","title":"<code>after</code>","text":"<pre><code>import { EndpointRequirements, RequestClient, ResponseClient } from '@syngenta-digital/acai-ts';\nimport * as db from 'api/logic/database';\n\nexport const requirements: EndpointRequirements = {\n    get: {\n        after: async (request: RequestClient, response: ResponseClient, requirements: any): Promise&lt;ResponseClient&gt; =&gt; {\n            const relations = await db.getRequesterRelations(request.headers['x-requester-id']);\n            const results: any[] = []\n            for (const grower of response.rawBody){\n                if (relations.includes(grower.id)){\n                    results.push(grower);\n                }\n            }\n            response.body = results;\n            return response;\n        }\n    }\n};\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#dataclass","title":"<code>dataClass</code>","text":"Info <p>Instead of getting a <code>request</code> and <code>response</code> as arguments passed to your API function, you will get an instance of the class you provided here</p> <pre><code>import { EndpointRequirements } from '@syngenta-digital/acai-ts';\nimport { Grower } from 'api/logic/grower';\n\nexport const requirements: EndpointRequirements = {\n    post: {\n        dataClass: Grower\n    }\n};\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#timeout","title":"<code>timeout</code>","text":"Info <p>This value will OVERRIDE any value set in the global timeout settings, set in the router config</p> <pre><code>import { EndpointRequirements } from '@syngenta-digital/acai-ts';\n\nexport const requirements: EndpointRequirements = {\n    post: {\n        timeout: 20000 // overrides other timeouts set in router config\n    }\n};\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#custom-requirements-example","title":"custom requirements (example)","text":"Info <p>You can add as many custom requirements as you want, with any variable type you want, and they will be passed to your <code>beforeAll</code>, <code>before</code>, <code>afterAll</code>, <code>after</code> and <code>withAuth</code> middleware defined functions.</p> <pre><code>import { EndpointRequirements } from '@syngenta-digital/acai-ts';\n\ninterface CustomPermission {\n    permission: string;\n}\n\nexport const requirements: EndpointRequirements = {\n    post:{\n        myCustomBeforeAllPermission: {permission: 'allow-delete-grower'} as CustomPermission\n    }\n};\n</code></pre>"},{"location":"apigateway/endpoint/setup/","title":"Endpoint Set Up","text":"<p>Each endpoint is meant to be treated as a separate module within the API. These endpoints are not meant to be extended or commingled and thus should approach individually. If resources are meant to be shared across endpoints, then those resources should be packaged as shared classes or utilities.</p> <p>Each endpoint should read as a procedural list of steps to be completed. To help keep this list clean and easy to read, the Acai follows its philosophy of \"Happy Path Programming.\" To achieve this, the Acai comes with a plethora of validation configurations with the ability to extend with even more customized validation options. This ensures the request sent to your endpoint will be correct with little need for exception handling or complex conditionals.</p> Examples <p>Don't like reading documentation? Then look at our examples, which can run locally!</p>"},{"location":"apigateway/endpoint/setup/#1-match-function-to-http-method","title":"1. Match Function to HTTP Method","text":"<p>Each endpoint must have stateless functions which match the name of the HTTP method. If endpoint is called the a <code>POST</code> HTTP method, then the <code>post</code> endpoint function is invoked.</p> <pre><code>// example for endpoint file: api/grower.ts\n\nimport { RequestClient, ResponseClient } from 'acai-ts';\n\nexport const requirements = {}; // discussed in next section below\n\nexport const post = async (request: RequestClient, response: ResponseClient): Promise&lt;ResponseClient&gt; =&gt; {\n    response.body = {message: '[POST] /grower was called'};\n    return response;\n};\n\nexport const get = async (request: RequestClient, response: ResponseClient): Promise&lt;ResponseClient&gt; =&gt; {\n    response.body = {message: '[GET] /grower was called'};\n    return response;\n};\n\nexport const patch = async (request: RequestClient, response: ResponseClient): Promise&lt;ResponseClient&gt; =&gt; {\n    response.body = {message: '[PATCH] /grower was called'};\n    return response;\n};\n\nexport const put = async (request: RequestClient, response: ResponseClient): Promise&lt;ResponseClient&gt; =&gt; {\n    response.body = {message: '[PUT] /grower was called'};\n    return response;\n};\n\nexport const deleteMethod = async (request: RequestClient, response: ResponseClient): Promise&lt;ResponseClient&gt; =&gt; {\n    response.body = {message: '[DELETE] /grower was called'};\n    return response;\n};\n\nexport const query = async (request: RequestClient, response: ResponseClient): Promise&lt;ResponseClient&gt; =&gt; {\n    response.body = {message: '[QUERY] /grower, a custom http method, was called'};\n    return response;\n};\n</code></pre>"},{"location":"apigateway/endpoint/setup/#2-configure-the-requirements-optional","title":"2. Configure the Requirements (optional)","text":"<p>Each method within the endpoint file can have individual validation requirements. These requirements allow you to test all structural points of the request, with the ability to use JSONSchema and custom middleware to further extend the validation options. Below is an example of a full requirements object:</p> Info <p>See the full configuration list, explanation and example of each setting in our Configurations Section.</p> Tip <p>If you are already using an <code>openapi.yml</code>, none of these requirements below are necessary. Ensure your <code>router</code> has enabled <code>autoValidate</code> with proper <code>schemaPath</code> configured and the below requirements are not necessary for any basic structural validation (headers, body, query, params will be checked via openapi.yml). You can still use <code>before</code>, <code>after</code> &amp; <code>dataClass</code> with other custom validations for more advanced use cases.</p> <pre><code>// example for endpoint file: api/grower.ts\n\nimport { RequestClient, ResponseClient, EndpointRequirements } from 'acai-ts';\nimport { Grower } from 'api/logic/grower';\nimport * as db from 'api/logic/database';\n\nexport const requirements: EndpointRequirements = {\n    post: {\n        requiredHeaders: ['x-onbehalf-of'],\n        availableHeaders: ['x-requester-id', 'x-test-id'], //not advisable to use; too strict\n        requiredBody: 'post-grower-request'\n    },\n    get: {\n        requiredQuery: ['requester_id'],\n        availableQuery: ['grower_email', 'grower_phone', 'grower_first', 'grower_last'],\n    },\n    put: {\n        requiredPath: 'grower/{id}',\n        requiredAuth: true,\n        requiredBody: 'put-grower-request',\n        dataClass: Grower,\n        timeout: 1500, // will override timeout value set in router config\n    },\n    patch: {\n        requiredPath: 'grower/{id}',\n        requiredAuth: true,\n        requiredBody: 'patch-grower-request',\n        before: async (request: RequestClient, response: ResponseClient, requirements: any): Promise&lt;void&gt; =&gt; {\n            // might be cleaner to put this in a separate file and call in context.\n            const result = await db.checkGrowerIdExists(request.pathParams.id);\n            if (!result){\n                response.setError('grower/{id}', `grower with id: ${request.pathParams.id} does not exist.`);\n            }\n        }\n    },\n    delete: {\n        requiredPath: 'grower/{id}',\n        after: async (request: RequestClient, response: ResponseClient, requirements: any): Promise&lt;ResponseClient&gt; =&gt; {\n            // might be cleaner to put this in a separate file and call in context.\n            const relations = await db.getRequesterRelations(request.headers['x-requester-id']);\n            const results: any[] = []\n            for (const grower of response.rawBody){\n                if (relations.includes(grower.id)){\n                    results.push(grower);\n                }\n            }\n            response.body = results;\n            return response;\n        }\n    }\n};\n\nexport const post = async (request: RequestClient, response: ResponseClient): Promise&lt;ResponseClient&gt; =&gt; {\n    response.body = {message: '[POST] /grower was called'};\n    return response;\n};\n\nexport const get = async (request: RequestClient, response: ResponseClient): Promise&lt;ResponseClient&gt; =&gt; {\n    response.body = {message: '[GET] /grower was called'};\n    return response;\n};\n\nexport const patch = async (request: RequestClient, response: ResponseClient): Promise&lt;ResponseClient&gt; =&gt; {\n    response.body = {message: '[PATCH] /grower was called'};\n    return response;\n};\n\nexport const put = async (grower: Grower, response: ResponseClient): Promise&lt;ResponseClient&gt; =&gt; {\n    response.body = {message: '[PUT] /grower was called; got instance of grower instead of request'};\n    return response;\n};\n\nexport const deleteMethod = async (request: RequestClient, response: ResponseClient): Promise&lt;ResponseClient&gt; =&gt; {\n    response.body = {message: '[DELETE] /grower was called'};\n    return response;\n};\n\nexport const query = async (request: RequestClient, response: ResponseClient): Promise&lt;ResponseClient&gt; =&gt; {\n    response.body = {message: '[QUERY] /grower, a custom http method, was called'};\n    return response;\n};\n</code></pre>"},{"location":"apigateway/router/configurations/","title":"Router Configurations","text":"<p>As mentioned previously, the router is highly configurable to each project needs and desires. The point of the router is to enforce predictable thus making the API more extensible. Below is a table of all the configuration options available:</p> Example <p>Don't like reading documentation? Then look at our examples which can run locally!</p>"},{"location":"apigateway/router/configurations/#configuration-options","title":"Configuration Options","text":"option type required description <code>afterAll</code> function no will call this function after EVERY request to the API <code>autoValidate</code> boolean no; requires <code>schemaPath</code> will automatically validate request against openapi.yml <code>basePath</code> string yes the base path of the API Gateway instance this is running on <code>beforeAll</code> function no will call this function before EVERY request to the API <code>cacheSize</code> number no (default: 128) caches the routes and modules (not responses) for faster subsequent requests <code>cacheMode</code> enum no; all (default), static, dynamic determines which routes to cache; all, routes with dynamic paths or static only <code>globalLogger</code> boolean no will assign the Acai logger to the global variable <code>globalLogger</code> <code>handlerPath</code> string yes, if <code>routingMode</code> == 'directory' file path pointing to the directory where the endpoints are <code>handlerPattern</code> string yes, if <code>routingMode</code> == 'pattern' glob pattern to be able to find the endpoint files <code>handlerList</code> object yes, if <code>routingMode</code> == 'list' object key, value pair to be able to map routes to files <code>loggerCallback</code> function no will call this function on every call to <code>global.logger</code> <code>onError</code> function no will call this function on every unhandled error; not including validation errors <code>outputError</code> boolean no, (default: false) determines if internal service error messages are outputed by api or just default <code>routingMode</code> enum yes; directory or pattern or list determines how to route requests to the right files; 3 modes <code>schemaPath</code> string yes, if <code>autoValidate</code> file path pointing to the location of the openapi.yml file <code>withAuth</code> function no will call this function when <code>requirements</code> have <code>requiredAuth</code> set to <code>true</code> <code>validateResponse</code> boolean no will validate the response from the api against openapi file or passed in schema <code>timeout</code> number no set timeout for all endpoints in your app separate from lambda configurations <code>onTimeout</code> function no will call when exceeding timeout setting; have more control on what to do next"},{"location":"apigateway/router/configurations/#example-router-config-with-directory-routing","title":"Example: Router Config with Directory Routing","text":"<pre><code>import { Router, RequestClient, ResponseClient } from '@syngenta-digital/acai-ts';\nimport { APIGatewayProxyEventV2 } from 'aws-lambda';\nimport { MiddlewareUtils } from 'api/logic/utils/middleware';\nimport { Authenticator } from 'api/logic/authenticator';\n\nconst router = new Router({\n    basePath: 'api',\n    routingMode: 'directory',\n    handlerPath: 'api/handler',\n    schemaPath: 'api/openapi.yml',\n    autoValidate: true,\n    globalLogger: true,\n    cacheSize: 512,\n    cacheMode: 'all',\n    timeout: 2800, // in microseconds,\n    onTimeout: MiddlewareUtils.onTimeout,\n    validateResponse: process.env.STAGE !== 'prod', // useful for lower environments\n    outputError: process.env.STAGE !== 'prod', // useful for lower environments\n    beforeAll: MiddlewareUtils.beforeAll,\n    afterAll: MiddlewareUtils.afterAll,\n    onError: MiddlewareUtils.onError,\n    withAuth: Authenticator.authenticate,\n    loggerCallback: MiddlewareUtils.loggerCallback,\n});\nrouter.autoLoad() // optional; pulls in files from disc into memory and shares on with concurrent lambdas\n\nexport const route = async (event: APIGatewayProxyEventV2) =&gt; {\n    return router.route(event);\n};\n</code></pre>"},{"location":"apigateway/router/configurations/#example-router-config-with-pattern-routing","title":"Example: Router Config with Pattern Routing","text":"<pre><code>import { Router, RequestClient, ResponseClient } from '@syngenta-digital/acai-ts';\nimport { APIGatewayProxyEventV2 } from 'aws-lambda';\nimport { MiddlewareUtils } from 'api/logic/utils/middleware';\nimport { Authenticator } from 'api/logic/authenticator';\n\nconst router = new Router({\n    basePath: 'api',\n    routingMode: 'pattern',\n    handlerPattern: 'api/**/*.controller.ts',\n    schemaPath: 'api/openapi.yml',\n    autoValidate: true,\n    globalLogger: true,\n    cacheSize: 512,\n    cacheMode: 'all',\n    timeout: 2800, // in microseconds,\n    onTimeout: MiddlewareUtils.onTimeout,\n    validateResponse: process.env.STAGE !== 'prod', // useful for lower environments\n    outputError: process.env.STAGE !== 'prod', // useful for lower environments\n    beforeAll: MiddlewareUtils.beforeAll,\n    afterAll: MiddlewareUtils.afterAll,\n    onError: MiddlewareUtils.onError,\n    withAuth: Authenticator.authenticate,\n    loggerCallback: MiddlewareUtils.loggerCallback,\n});\nrouter.autoLoad() // optional; pulls in files from disc into memory and shares on with concurrent lambdas\n\nexport const route = async (event: APIGatewayProxyEventV2) =&gt; {\n    return router.route(event);\n};\n</code></pre>"},{"location":"apigateway/router/configurations/#example-router-config-with-list-routing","title":"Example: Router Config with List Routing","text":"<pre><code>import { Router, RequestClient, ResponseClient } from '@syngenta-digital/acai-ts';\nimport { APIGatewayProxyEventV2 } from 'aws-lambda';\nimport { MiddlewareUtils } from 'api/logic/utils/middleware';\nimport { Authenticator } from 'api/logic/authenticator';\n\n// best to put this is in separate file; but the sake of brevity...\ninterface RouteMap {\n    [key: string]: string;\n}\n\nconst routes: RouteMap = {\n    'GET::grower': 'api/routes/grower.ts',\n    'POST::farm': 'api/routes/farm.ts',\n    'PUT:farm/{farmId}/field/{fieldId}': 'api/routes/farm-field.ts'\n}\n\nconst router = new Router({\n    basePath: 'api',\n    routingMode: 'list',\n    handlerList: routes,\n    schemaPath: 'api/openapi.yml',\n    autoValidate: true,\n    globalLogger: true,\n    cacheSize: 512,\n    cacheMode: 'all',\n    timeout: 2800, // in microseconds,\n    onTimeout: MiddlewareUtils.onTimeout,\n    validateResponse: process.env.STAGE !== 'prod', // useful for lower environments\n    outputError: process.env.STAGE !== 'prod', // useful for lower environments\n    beforeAll: MiddlewareUtils.beforeAll,\n    afterAll: MiddlewareUtils.afterAll,\n    onError: MiddlewareUtils.onError,\n    withAuth: Authenticator.authenticate,\n    loggerCallback: MiddlewareUtils.loggerCallback\n});\n\nrouter.autoLoad() // optional; pulls in files from disc into memory and shares on with concurrent lambdas\n\nexport const route = async (event: APIGatewayProxyEventV2) =&gt; {\n    return router.route(event);\n};\n</code></pre>"},{"location":"apigateway/router/setup/","title":"Router Set Up","text":"Example <p>Don't like reading documentation? Then look at our examples which can run locally!</p>"},{"location":"apigateway/router/setup/#1-configure-the-lambda","title":"1. Configure the Lambda","text":"Serverless Framework <pre><code>functions:\n    apigateway-handler:\n        handler: api/handler/router.route\n        events:\n            - http:\n                path: /\n                method: ANY\n            - http:\n                path: /{proxy+}\n                method: ANY\n</code></pre>"},{"location":"apigateway/router/setup/#2-configure-the-router","title":"2. Configure the Router","text":"<p>There are three routing modes: <code>directory</code>, <code>pattern</code> and <code>list</code>; <code>directory</code> and <code>pattern</code> routing mode requires your project files to be placed in a particular way; <code>list</code> does not require any structure, as you define every route and it's corresponding file. Below are the three ways configure your router:</p>"},{"location":"apigateway/router/setup/#routing-mode-directory","title":"Routing Mode: Directory","text":"Tip <p>If you are using route params, you will need use dynamic file names which follow this pattern: <code>{some-variable-name}.ts</code>.</p> file structurerouter.ts <pre><code>~~ Directory ~~                     ~~ Route ~~\n===================================================================\n=api/                              |\n---=handler                       |\n    ---=router.ts                 |\n    ---=org.ts                    | /org\n    ---=grower                    |\n        ---=index.ts              | /grower\n        ---={growerId}.ts         | /grower/{growerId}\n    ---=farm                      |\n        ---=index.ts              | /farm\n        ---={farmId}              |\n            ---=index.ts          | /farm/{farmId}\n            ---=field             |\n                ---=index.ts      | /farm/{farmId}/field\n                ---={fieldId}.ts  | /farm/{farmId}/field/{fieldId}\n</code></pre> <pre><code>import { Router } from 'acai-ts';\nimport { APIGatewayProxyEventV2 } from 'aws-lambda';\n\nconst router = new Router({\n    mode: 'directory',\n    basePath: 'api', // for use with custom apigateway domain\n    routesPath: 'api/handler'\n});\nrouter.autoLoad() // optional; pulls in files from disc into memory and shares on with concurrent lambdas\n\nexport const route = async (event: APIGatewayProxyEventV2) =&gt; {\n    return router.route(event);\n};\n</code></pre>"},{"location":"apigateway/router/setup/#routing-mode-pattern","title":"Routing Mode: Pattern","text":"Tip <p>You can use any glob pattern you like; common patterns are:</p> <ul> <li> <p><code>/**/*.controller.ts</code></p> </li> <li> <p><code>/**/handler.*.ts</code></p> </li> <li> <p><code>/**/endpoint.ts</code></p> </li> </ul> file structurerouter.ts <pre><code>~~ Pattern ~~                               ~~ Route ~~\n================================================================================\n=api/                                      |\n---=router.ts                             |\n---=org                                   |\n    ---=org.controller.ts                 | /org\n    ---=org.model.ts                      |\n    ---=org.factory.ts                    |\n    ---=org.logic.ts                      |\n---=grower                                |\n    ---=grower.controller.ts              | /grower\n    ---={growerId}.controller.ts          | /grower/{growerId}\n    ---=grower.model.ts                   |\n    ---=grower.factory.ts                 |\n    ---=grower.logic.ts                   |\n---=farm                                  |\n    ---=farm.controller.ts                | /farm\n    ---=farm.logic.ts                     |\n    ---=farm.model.ts                     |\n    ---={farmId}                          |\n        ---={farmId}.controller.ts        | /farm/{farmId}\n        ---=field                         |\n            ---=field.controller.ts       | /farm/{farmId}/field\n            ---={fieldId}.controller.ts   | /farm/{farmId}/field/{fieldId}\n            ---=field.logic.ts            |\n            ---=field.model.ts            |\n</code></pre> <pre><code>import { Router } from 'acai-ts';\nimport { APIGatewayProxyEventV2 } from 'aws-lambda';\n\nexport const route = async (event: APIGatewayProxyEventV2) =&gt; {\n    const router = new Router({\n        mode: 'pattern',\n        basePath: 'api', // for use with custom apigateway domain\n        routesPath: 'api/**/*.controller.ts'\n    });\n    return router.route(event);\n};\n</code></pre>"},{"location":"apigateway/router/setup/#routing-mode-list","title":"Routing Mode: List","text":"Tip <p>It may be more maintainable to store your routes list in a separate file, this example does not have that for brevity</p> Warning <p>Even though you are matching your files to your routes, the handler files must have functions that match HTTP method (see endpoint examples here)</p> Danger <p>This is not the preferred routing mode to use; this can lead to a sloppy, unpredictable project architecture which will be hard to maintain and extend. This is NOT RECOMMENDED.</p> file structurerouter.ts <pre><code>File structure doesn't matter\n======================================================\n=api/\n---=router.ts\n</code></pre> <pre><code>import { Router } from 'acai-ts';\nimport { APIGatewayProxyEventV2 } from 'aws-lambda';\n\nconst router = new Router({\n    mode: 'list',\n    basePath: 'api', // for use with custom apigateway domain\n    routes: [\n        { method: 'GET', path: '/grower', handler: 'api/routes/grower.ts' },\n        { method: 'POST', path: '/farm', handler: 'api/routes/farm.ts' },\n        { method: 'PUT', path: '/farm/{farmId}/field/{fieldId}', handler: 'api/routes/farm-field.ts' }\n    ]\n});\n\nrouter.autoLoad() // optional; pulls in files from disc into memory and shares on with concurrent lambdas\n\nexport const route = async (event: APIGatewayProxyEventV2) =&gt; {\n    return router.route(event);\n};\n</code></pre>"},{"location":"apigateway/router/setup/#3-configure-the-endpoint-file","title":"3. Configure the Endpoint File","text":"<p>Every endpoint file should contain a function which matches an HTTP method in lower case. Most common are <code>post</code>, <code>get</code>, <code>put</code>, <code>patch</code>, <code>delete</code>, but this library does support custom methods, if you so choose. As long as the method of the request matches the function name, it will work.</p> <pre><code>import { RequestClient, ResponseClient } from 'acai-ts';\n\nexport const post = async (request: RequestClient, response: ResponseClient): Promise&lt;ResponseClient&gt; =&gt; {\n    response.body = {post: true};\n    return response;\n};\n\nexport const get = async (request: RequestClient, response: ResponseClient): Promise&lt;ResponseClient&gt; =&gt; {\n    response.body = {get: true};\n    return response;\n};\n\nexport const patch = async (request: RequestClient, response: ResponseClient): Promise&lt;ResponseClient&gt; =&gt; {\n    response.body = {patch: true};\n    return response;\n};\n\nexport const put = async (request: RequestClient, response: ResponseClient): Promise&lt;ResponseClient&gt; =&gt; {\n    response.body = {put: true};\n    return response;\n};\n\nexport const deleteMethod = async (request: RequestClient, response: ResponseClient): Promise&lt;ResponseClient&gt; =&gt; {\n    response.body = {delete: true};\n    return response;\n};\n\n// this is a non-compliant, custom http method; this will work.\nexport const query = async (request: RequestClient, response: ResponseClient): Promise&lt;ResponseClient&gt; =&gt; {\n    response.body = [{query: true}];\n    return response;\n};\n</code></pre>"},{"location":"common/logger/","title":"Logger","text":"<p>The Acai-TS logger automatically logs in a formatted JSON string for easy reading and searching with AWS CloudWatch. A developer can then use AWS filter patterns making it effortless to find the exact log they are looking for. Below is an example of how to use the logger:</p>"},{"location":"common/logger/#examples","title":"Examples","text":""},{"location":"common/logger/#basic-usage","title":"Basic Usage","text":"<pre><code>import { Logger } from 'acai-ts';\n\n// If you use globalLogger: true in any config, the logger is available globally\nLogger.info('testing info');\n\nLogger.debug('testing debug');\n\nLogger.warn('testing warn');\n\nLogger.error('testing error');\n\n// Standard output\n{\n    level: '$LEVEL', \n    log: '$MESSAGE'\n}\n</code></pre>"},{"location":"common/logger/#advanced-usage","title":"Advanced Usage","text":"<pre><code>import { Logger } from 'acai-ts';\n\n// Custom log object with structured data\nLogger.log({ level: 'INFO', log: { someKey: 'testing info' } });\n\n// Standard output\n{\n    level: 'INFO',\n    log: {\n        someKey: 'testing info'\n    }\n}\n</code></pre>"},{"location":"common/logger/#global-logger-setup","title":"Global Logger Setup","text":"<pre><code>import { Logger } from 'acai-ts';\n\n// Set up global logger with custom callback\nLogger.setUpGlobal(true, {\n  callback: (level: string, ...args: any[]) =&gt; {\n    // Custom logging logic (e.g., send to CloudWatch, Datadog, etc.)\n    console.log(`[${level}]`, ...args);\n  }\n});\n\n// Now logger is available throughout your application\nLogger.info('Application started');\n</code></pre>"},{"location":"common/logger/#typescript-types","title":"TypeScript Types","text":"<pre><code>import { Logger } from 'acai-ts';\n\n// Logger methods are fully typed\nLogger.info('string message');                    // \u2705 Valid\nLogger.log({ level: 'INFO', log: 'message' });   // \u2705 Valid\nLogger.error('error', new Error('Something'));    // \u2705 Valid\n\n// Type-safe log levels\ntype LogLevel = 'DEBUG' | 'INFO' | 'WARN' | 'ERROR';\n\nconst level: LogLevel = 'INFO';\nLogger.log({ level, log: { data: 'value' } });\n</code></pre>"},{"location":"common/logger/#configuration-options","title":"Configuration Options","text":"<p>The logger can be configured when setting up your Event handlers or Router:</p> <pre><code>import { Event } from 'acai-ts';\nimport { DynamoDBStreamEvent } from 'aws-lambda';\n\nexport const handler = async (event: DynamoDBStreamEvent): Promise&lt;void&gt; =&gt; {\n  const dynamodb = new Event(event, {\n    globalLogger: true,  // Enable global logger\n    operations: ['INSERT', 'MODIFY']\n  });\n\n  // Logger is now available\n  Logger.info('Processing DynamoDB stream');\n\n  await dynamodb.process();\n};\n</code></pre>"},{"location":"decorators/","title":"Decorators","text":"<p>Acai-TS provides a powerful decorator-based approach for defining routes, middleware, and validation. Decorators offer a clean, declarative way to configure your endpoints without boilerplate code.</p> TypeScript Configuration Required <p>To use decorators, ensure your <code>tsconfig.json</code> includes: <pre><code>{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"target\": \"ES2020\"\n  }\n}\n</code></pre></p>"},{"location":"decorators/#quick-start","title":"Quick Start","text":"<pre><code>import 'reflect-metadata';\nimport { Route, Validate, Auth, Before, After, Timeout } from 'acai-ts';\n\nexport class UserController {\n  @Route('GET', '/users/:id')\n  @Auth(async (request) =&gt; {\n    // Simple authentication check\n    return request.headers.authorization?.startsWith('Bearer ') || false;\n  })\n  @Timeout(5000)\n  async getUser(request: Request, response: Response): Promise&lt;void&gt; {\n    response.setBody({ id: request.params.id, name: 'John Doe' });\n  }\n\n  @Route('POST', '/users')\n  @Validate({\n    body: {\n      type: 'object',\n      required: ['name', 'email'],\n      properties: {\n        name: { type: 'string', minLength: 2 },\n        email: { type: 'string', format: 'email' }\n      }\n    }\n  })\n  @Before(async (request) =&gt; {\n    console.log('Creating user:', request.body.email);\n  })\n  @After(async (request, response) =&gt; {\n    console.log('User created successfully');\n  })\n  async createUser(request: Request, response: Response): Promise&lt;void&gt; {\n    const { name, email } = request.body;\n    response.setStatus(201);\n    response.setBody({ id: Math.random(), name, email });\n  }\n}\n</code></pre>"},{"location":"decorators/#available-decorators","title":"Available Decorators","text":""},{"location":"decorators/#route","title":"@Route","text":"<p>Defines the HTTP method and path for an endpoint.</p> <pre><code>@Route(method: HttpMethod, path: string)\n</code></pre> <p>Parameters: - <code>method</code>: HTTP method (<code>'GET'</code>, <code>'POST'</code>, <code>'PUT'</code>, <code>'PATCH'</code>, <code>'DELETE'</code>, etc.) - <code>path</code>: Route path pattern (supports parameters like <code>/users/:id</code>)</p> <p>Examples: <pre><code>@Route('GET', '/users')\n@Route('POST', '/users')\n@Route('PUT', '/users/:id')\n@Route('DELETE', '/users/:id')\n@Route('GET', '/users/:id/posts/:postId')\n</code></pre></p>"},{"location":"decorators/#validate","title":"@Validate","text":"<p>Adds JSON Schema validation to the request.</p> <pre><code>@Validate(schema: ValidationSchema)\n</code></pre> <p>Examples: <pre><code>// Body validation\n@Validate({\n  body: {\n    type: 'object',\n    required: ['name', 'email'],\n    properties: {\n      name: { type: 'string', minLength: 2, maxLength: 50 },\n      email: { type: 'string', format: 'email' }\n    }\n  }\n})\n\n// Query parameters validation\n@Validate({\n  query: {\n    type: 'object',\n    properties: {\n      page: { type: 'integer', minimum: 1 },\n      limit: { type: 'integer', minimum: 1, maximum: 100 }\n    }\n  }\n})\n\n// Headers validation\n@Validate({\n  headers: {\n    type: 'object',\n    required: ['x-api-key'],\n    properties: {\n      'x-api-key': { type: 'string', minLength: 10 }\n    }\n  }\n})\n</code></pre></p>"},{"location":"decorators/#auth","title":"@Auth","text":"<p>Adds authentication middleware to the endpoint.</p> <pre><code>@Auth(authFunction: (request: Request) =&gt; Promise&lt;boolean&gt; | boolean)\n</code></pre> <p>Examples: <pre><code>// Simple token check\n@Auth(async (request) =&gt; {\n  const token = request.headers.authorization?.replace('Bearer ', '');\n  return token === 'valid-token-123';\n})\n\n// Database user validation\n@Auth(async (request) =&gt; {\n  const token = request.headers.authorization?.replace('Bearer ', '');\n  if (!token) return false;\n\n  const user = await validateUserToken(token);\n  return user !== null;\n})\n\n// Role-based authentication\n@Auth(async (request) =&gt; {\n  const user = await getCurrentUser(request);\n  return user?.role === 'admin';\n})\n</code></pre></p>"},{"location":"decorators/#before","title":"@Before","text":"<p>Adds middleware that runs before the main handler.</p> <pre><code>@Before(middleware: (request: Request, response?: Response) =&gt; Promise&lt;void&gt; | void)\n</code></pre> <p>Examples: <pre><code>// Logging\n@Before(async (request) =&gt; {\n  console.log(`${request.method} ${request.path} - ${new Date().toISOString()}`);\n})\n\n// Rate limiting\n@Before(async (request, response) =&gt; {\n  const clientIp = request.headers['x-forwarded-for'] || 'unknown';\n  if (await isRateLimited(clientIp)) {\n    response.setStatus(429);\n    response.setError('rate_limit', 'Too many requests');\n  }\n})\n\n// Data preprocessing\n@Before(async (request) =&gt; {\n  if (request.body?.email) {\n    request.body.email = request.body.email.toLowerCase().trim();\n  }\n})\n</code></pre></p>"},{"location":"decorators/#after","title":"@After","text":"<p>Adds middleware that runs after the main handler.</p> <pre><code>@After(middleware: (request: Request, response: Response) =&gt; Promise&lt;void&gt; | void)\n</code></pre> <p>Examples: <pre><code>// Response logging\n@After(async (request, response) =&gt; {\n  console.log(`Response: ${response.statusCode} for ${request.path}`);\n})\n\n// Add security headers\n@After(async (request, response) =&gt; {\n  response.setHeader('X-Content-Type-Options', 'nosniff');\n  response.setHeader('X-Frame-Options', 'DENY');\n})\n\n// Data post-processing\n@After(async (request, response) =&gt; {\n  if (response.body?.users) {\n    response.body.users = response.body.users.map(user =&gt; ({\n      ...user,\n      password: undefined // Remove sensitive data\n    }));\n  }\n})\n</code></pre></p>"},{"location":"decorators/#timeout","title":"@Timeout","text":"<p>Sets a timeout for the endpoint.</p> <pre><code>@Timeout(milliseconds: number)\n</code></pre> <p>Examples: <pre><code>@Timeout(5000)  // 5 second timeout\n@Timeout(30000) // 30 second timeout for heavy operations\n@Timeout(1000)  // 1 second timeout for quick operations\n</code></pre></p>"},{"location":"decorators/#combining-decorators","title":"Combining Decorators","text":"<p>Decorators can be combined and will execute in the following order:</p> <ol> <li>@Auth - Authentication check</li> <li>@Validate - Request validation</li> <li>@Before - Pre-processing middleware</li> <li>Handler - Your main function</li> <li>@After - Post-processing middleware</li> <li>@Timeout - Applied throughout the entire request</li> </ol> <pre><code>export class OrderController {\n  @Route('POST', '/orders')\n  @Auth(async (request) =&gt; await validateUser(request))\n  @Validate({\n    body: {\n      type: 'object',\n      required: ['items', 'total'],\n      properties: {\n        items: { type: 'array', minItems: 1 },\n        total: { type: 'number', minimum: 0 }\n      }\n    }\n  })\n  @Before(async (request) =&gt; {\n    request.body.orderId = generateOrderId();\n    request.body.timestamp = Date.now();\n  })\n  @After(async (request, response) =&gt; {\n    await sendOrderConfirmation(response.body.orderId);\n  })\n  @Timeout(10000)\n  async createOrder(request: Request, response: Response): Promise&lt;void&gt; {\n    const order = await processOrder(request.body);\n    response.setStatus(201);\n    response.setBody(order);\n  }\n}\n</code></pre>"},{"location":"decorators/#router-configuration-for-decorators","title":"Router Configuration for Decorators","text":"<p>When using decorators, your router configuration can be simplified:</p> <pre><code>import 'reflect-metadata';\nimport { Router } from 'acai-ts';\nimport { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\n\nconst router = new Router({\n  mode: 'list',\n  routes: [], // Routes are defined via decorators\n  timeout: 30000,\n  outputError: true\n});\n\nexport const handler = async (\n  event: APIGatewayProxyEvent\n): Promise&lt;APIGatewayProxyResult&gt; =&gt; {\n  return await router.route(event);\n};\n</code></pre>"},{"location":"decorators/#best-practices","title":"Best Practices","text":""},{"location":"decorators/#1-keep-decorators-simple","title":"1. Keep Decorators Simple","text":"<pre><code>// \u2705 Good - Simple, focused logic\n@Auth(async (request) =&gt; Boolean(request.headers.authorization))\n\n// \u274c Avoid - Complex logic in decorators\n@Auth(async (request) =&gt; {\n  // 20 lines of complex authentication logic\n  // Better to extract to a separate function\n})\n</code></pre>"},{"location":"decorators/#2-use-multiple-beforeafter-for-different-concerns","title":"2. Use Multiple @Before/@After for Different Concerns","text":"<pre><code>// \u2705 Good - Separate concerns\n@Before(logRequest)\n@Before(validateBusinessRules)\n@Before(enrichRequestData)\n\n// \u274c Avoid - Single decorator doing everything\n@Before(async (request) =&gt; {\n  // logging + validation + enrichment all in one\n})\n</code></pre>"},{"location":"decorators/#3-consistent-error-handling","title":"3. Consistent Error Handling","text":"<pre><code>@Auth(async (request) =&gt; {\n  try {\n    return await validateToken(request.headers.authorization);\n  } catch (error) {\n    console.error('Auth error:', error);\n    return false; // Always return boolean from @Auth\n  }\n})\n</code></pre>"},{"location":"decorators/#4-type-safety","title":"4. Type Safety","text":"<pre><code>interface CreateUserRequest {\n  name: string;\n  email: string;\n  age?: number;\n}\n\n@Route('POST', '/users')\n@Validate({\n  body: {\n    type: 'object',\n    required: ['name', 'email'],\n    properties: {\n      name: { type: 'string' },\n      email: { type: 'string', format: 'email' },\n      age: { type: 'integer', minimum: 0 }\n    }\n  }\n})\nasync createUser(request: Request&lt;CreateUserRequest&gt;, response: Response): Promise&lt;void&gt; {\n  // TypeScript knows request.body is CreateUserRequest\n  const { name, email, age } = request.body;\n}\n</code></pre>"},{"location":"decorators/#migration-from-functional-approach","title":"Migration from Functional Approach","text":""},{"location":"decorators/#before-functional","title":"Before (Functional)","text":"<pre><code>export const requirements = {\n  post: {\n    requiredAuth: true,\n    requiredBody: 'CreateUserSchema',\n    timeout: 5000\n  }\n};\n\nexport const post = async (request: RequestClient, response: ResponseClient) =&gt; {\n  response.body = { id: 123, ...request.body };\n  return response;\n};\n</code></pre>"},{"location":"decorators/#after-decorators","title":"After (Decorators)","text":"<pre><code>export class UserController {\n  @Route('POST', '/users')\n  @Auth(async (request) =&gt; validateUser(request))\n  @Validate({ body: CreateUserSchema })\n  @Timeout(5000)\n  async createUser(request: Request, response: Response): Promise&lt;void&gt; {\n    response.setBody({ id: 123, ...request.body });\n  }\n}\n</code></pre>"},{"location":"decorators/#common-patterns","title":"Common Patterns","text":""},{"location":"decorators/#crud-operations","title":"CRUD Operations","text":"<pre><code>export class UserController {\n  @Route('GET', '/users')\n  @Auth(requireAuth)\n  async listUsers(request: Request, response: Response): Promise&lt;void&gt; {\n    const users = await getUserList();\n    response.setBody({ users });\n  }\n\n  @Route('GET', '/users/:id')\n  @Auth(requireAuth)\n  async getUser(request: Request, response: Response): Promise&lt;void&gt; {\n    const user = await getUserById(request.params.id);\n    response.setBody(user);\n  }\n\n  @Route('POST', '/users')\n  @Auth(requireAdminAuth)\n  @Validate({ body: CreateUserSchema })\n  async createUser(request: Request, response: Response): Promise&lt;void&gt; {\n    const user = await createUser(request.body);\n    response.setStatus(201);\n    response.setBody(user);\n  }\n\n  @Route('PUT', '/users/:id')\n  @Auth(requireOwnerOrAdmin)\n  @Validate({ body: UpdateUserSchema })\n  async updateUser(request: Request, response: Response): Promise&lt;void&gt; {\n    const user = await updateUser(request.params.id, request.body);\n    response.setBody(user);\n  }\n\n  @Route('DELETE', '/users/:id')\n  @Auth(requireAdminAuth)\n  async deleteUser(request: Request, response: Response): Promise&lt;void&gt; {\n    await deleteUser(request.params.id);\n    response.setStatus(204);\n  }\n}\n</code></pre> <p>For more detailed examples and advanced usage patterns, see our troubleshooting guide and the example code on GitHub.</p>"},{"location":"dynamodb/","title":"DynamoDB","text":"<p>Event handler for Amazon DynamoDB Stream Events.</p>"},{"location":"dynamodb/#features","title":"Features","text":"<ul> <li>Automatically convert DynamoDB JSON to standard JSON</li> <li>Only run on certain DynamoDB operations, like on when items are created, updated or deleted</li> <li>Able to validate DynamoDB record against a JSON Schema</li> <li>Assign Data Classes to records instead of getting raw DynamoDB JSON objects</li> </ul>"},{"location":"dynamodb/configurations/","title":"DynamoDB Event Configurations","text":"<p>The Dynamodb event will automatically handle many common things done when eventing off a DynamoDB stream. Developers then have the ability to further extend that functionality with custom middleware. Below is a full list of all the configurations available and examples of their use.</p> Examples <p>Don't like reading documentation? Then look at our examples, which can be deployed in 1 command into your AWS account! </p>"},{"location":"dynamodb/configurations/#configuration-options","title":"Configuration Options","text":"option type required default description <code>before</code> func no null a custom function to be ran before your records are pulled <code>dataClass</code> class no null a custom class that will be passed instead of the records object <code>globalLogger</code> bool no false will assign the Acai logger to the global variable <code>globalLogger</code> <code>operations</code> array no ['create', 'update', 'delete'] will only run if record was created from the listed operation <code>operationError</code> bool no false will raise exception if operation of record is not from listed operations <code>requiredBody</code> str or obj no null will validate body of record against this schema <code>schemaPath</code> str no null file path pointing to the location of the openapi.yml file <code>validationError</code> bool no false will raise exception if validation of record fails"},{"location":"dynamodb/configurations/#example-dynamodb-configuration-options","title":"Example: DynamoDB Configuration Options","text":"<pre><code>import { DynamoDBStreamEvent } from 'aws-lambda';\nimport { Event } from 'acai-ts';\nimport { Grower } from './api/logic/grower';\n\nexport const handler = async (event: DynamoDBStreamEvent): Promise&lt;void&gt; =&gt; {\n    const options = {\n        globalLogger: true,\n        operations: ['create', 'update'], // [create, update, delete] by default\n        operationError: false, // will raise exception if wrong operation;  default false\n        requiredBody: 'ddb-record',\n        schemaPath: 'api/openapi.yml',\n        validationError: false, // will raise exception if validation fails;  default false\n        dataClass: Grower, // will get instance of this instead of record instance\n        before: (records: any[]) =&gt; {\n            // run this before records are sent\n        }\n    };\n    const eventClient = new Event.dynamodb(event, options);\n    const records = await eventClient.getRecords();\n    for (const grower of records) {\n        // do stuff here\n    }\n};\n</code></pre>"},{"location":"dynamodb/record/","title":"DynamoDB Record Object","text":"<p>The DynamoDB event will by default provide instances of <code>record</code> classes which will be easier to work with then a standard lambda event record object. This is the same object which will be passed down to the <code>dataClass</code>, if you provide on in your configuration. Below is a list of all the properties and example outputs for the DynamoDB event record:</p> Examples <p>Don't like reading documentation? Then look at our examples, which can be deployed in 1 command into your AWS account! </p>"},{"location":"dynamodb/record/#record-properties","title":"Record Properties","text":"property type description <code>body</code> object the new image of dynamodb record; created or updated <code>created</code> float the approximate creationDate time <code>expired</code> bool whether the ttl has expired <code>id</code> str the id of the event which invoked the lambda <code>identity</code> object the identity who triggered the dynamodb change <code>keys</code> object the keys of DynamoDB record <code>name</code> str the name of the event which invoked the lambda <code>newImage</code> object the new image of dynamodb record; created or updated <code>oldImage</code> object the old image of dynamodb record; updated or deleted <code>operation</code> str triggered operation lambda (create, update, delete) <code>region</code> str the region the record is from <code>size</code> int the size in bytes of the record <code>source</code> str the source of the event which invoked the lambda <code>sourceARN</code> str the event source arn <code>streamType</code> str the stream view type <code>version</code> str the event version"},{"location":"dynamodb/record/#recordregion","title":"<code>record.region</code>","text":"<pre><code>console.log(record.region);\n\n// example output:\n'us-east-2'\n</code></pre>"},{"location":"dynamodb/record/#recordid","title":"<code>record.id</code>","text":"<pre><code>console.log(record.id);\n\n// example output:\n'9a37c0d03eb60f7cf70cabc823de9907'\n</code></pre>"},{"location":"dynamodb/record/#recordname","title":"<code>record.name</code>","text":"<pre><code>console.log(record.name);\n\n// example output:\n'INSERT'\n</code></pre>"},{"location":"dynamodb/record/#recordsource","title":"<code>record.source</code>","text":"<pre><code>console.log(record.source);\n\n// example output:\n'aws:dynamodb'\n</code></pre>"},{"location":"dynamodb/record/#recordkeys","title":"<code>record.keys</code>","text":"Info <p>This is converted from the original DDB JSON to standard json</p> <pre><code>console.log(record.keys);\n\n// example output:\n{\n    example_id: '123456789'\n}\n</code></pre>"},{"location":"dynamodb/record/#recordoldimage","title":"<code>record.oldImage</code>","text":"Info <p>This is converted from the original DDB JSON to standard json</p> <pre><code>console.log(record.oldImage);\n\n// example output:\n{\n    old_data: '123456789'\n}\n</code></pre>"},{"location":"dynamodb/record/#recordnewimage","title":"<code>record.newImage</code>","text":"Info <p>This is converted from the original DDB JSON to standard json</p> <pre><code>console.log(record.newImage);\n\n// example output:\n{\n    new_data: '123456789'\n}\n</code></pre>"},{"location":"dynamodb/record/#recordbody","title":"<code>record.body</code>","text":"Info <p>This is converted from the original DDB JSON to standard json from <code>newImage</code></p> <pre><code>console.log(record.body);\n\n// example output:\n{\n    new_data: '123456789'\n}\n</code></pre>"},{"location":"dynamodb/record/#recordoperation","title":"<code>record.operation</code>","text":"<pre><code>console.log(record.operation);\n\n// example output:\n'create'\n</code></pre>"},{"location":"dynamodb/record/#recordsourcearn","title":"<code>record.sourceARN</code>","text":"<pre><code>console.log(record.sourceARN);\n\n// example output:\n'arn:aws:dynamodb:us-east-1:771875143460:table/test-example/stream/2019-10-04T23:18:26.340'\n</code></pre>"},{"location":"dynamodb/record/#recordversion","title":"<code>record.version</code>","text":"<pre><code>console.log(record.version);\n\n// example output:\n'1.1'\n</code></pre>"},{"location":"dynamodb/record/#recordstreamtype","title":"<code>record.streamType</code>","text":"<pre><code>console.log(record.streamType);\n\n// example output:\n'NEW_AND_OLD_IMAGES'\n</code></pre>"},{"location":"dynamodb/record/#recordsize","title":"<code>record.size</code>","text":"<pre><code>console.log(record.size);\n\n// example output:\n1124\n</code></pre>"},{"location":"dynamodb/record/#recordcreated","title":"<code>record.created</code>","text":"<pre><code>console.log(record.created);\n\n// example output:\n1538695200.0 //unix timestamp\n</code></pre>"},{"location":"dynamodb/record/#recordidentity","title":"<code>record.identity</code>","text":"<pre><code>console.log(record.identity);\n\n// example output:\n{\n    type: 'Service',\n    principalId: 'dynamodb.amazonaws.com'\n}\n</code></pre>"},{"location":"dynamodb/record/#recordexpired","title":"<code>record.expired</code>","text":"<pre><code>console.log(record.expired);\n\n// example output:\nfalse\n</code></pre>"},{"location":"s3/","title":"S3","text":"<p>Event handler for Amazon S3 Bucket Events.</p>"},{"location":"s3/#features","title":"Features","text":"<ul> <li>Automatically convert JSON files to JSON objects</li> <li>Automatically convert CSV files to JSON objects</li> <li>Only run on certain S3 operations, like on when items are created, updated or deleted</li> <li>Able to validate S3 record against a JSON Schema</li> <li>Assign Data Classes to records instead of getting raw S3 JSON objects</li> </ul>"},{"location":"s3/configurations/","title":"S3 Event Configurations","text":"<p>The S3 event will automatically handle many common things done when eventing off a S3 event. Developers then have the ability to further extend that functionality with custom middleware. Below is a full list of all the configurations available and examples of their use.</p> Examples <p>Don't like reading documentation? Then look at our examples, which can be deployed in 1 command into your AWS account! </p>"},{"location":"s3/configurations/#configuration-options","title":"Configuration Options","text":"option type required default description <code>before</code> func no null a custom function to be ran before your records are pulled <code>dataClass</code> class no null a custom class that will be passed instead of the records object <code>getObject</code> bool no false will pull the file from S3 bucket and hold in memory <code>globalLogger</code> bool no false will assign the Acai logger to the global variable <code>globalLogger</code> <code>isJSON</code> bool no false will convert file into JSON object; requires <code>getObject</code> <code>isCSV</code> bool no false will convert file into CSV object; requires <code>getObject</code> <code>operations</code> array no ['create', 'update', 'delete'] will only run if record was created from the listed operation <code>operationError</code> bool no false will raise exception if operation of record is not from listed operations <code>requiredBody</code> str or obj no null will validate body of record against this schema, requires <code>isJSON</code> <code>schemaPath</code> str no null file path pointing to the location of the openapi.yml file <code>validationError</code> bool no false will raise exception if validation of record fails"},{"location":"s3/configurations/#example-s3-configuration-options","title":"Example: S3 Configuration Options","text":"<pre><code>import { S3Event } from 'aws-lambda';\nimport { Event } from 'acai-ts';\nimport { Grower } from './api/logic/grower';\n\nexport const handler = async (event: S3Event): Promise&lt;void&gt; =&gt; {\n    const options = {\n        globalLogger: true,\n        operations: ['create', 'delete'], // [create, update, delete] by default; s3 doesn't support delete\n        operationError: false, // will raise exception if wrong operation;  default false\n        requiredBody: 's3-record', // only works with isJSON\n        schemaPath: 'api/openapi.yml', // only works with isJSON\n        validationError: false, // will raise exception if validation fails;  default false\n        getObject: true, // required for isJSON or isCSV\n        isJSON: true, // will convert file into JSON object, must be valid JSON file\n        isCSV: false, // will convert file into object, must be valid CSV file\n        dataClass: Grower, // will get instance of this instead of record instance\n        before: (records: any[]) =&gt; {\n            // run this before records are sent\n        }\n    };\n    const eventClient = new Event.s3(event, options);\n    const records = await eventClient.getRecords();\n    for (const grower of records) {\n        // do stuff here\n    }\n};\n</code></pre>"},{"location":"s3/record/","title":"S3 Record Object","text":"<p>The S3 event will by default provide instances of <code>record</code> classes which will be easier to work with then standard lambda event record object. This is the same object which will be passed down to the <code>dataClass</code>, if you provide on in your configuration. Below is a list of all the properties and example outputs for the S3 event record:</p> Example <p>Don't like reading documentation? Then look at our examples which can be deployed in 1 command into your AWS account! </p>"},{"location":"s3/record/#record-properties","title":"Record Properties","text":"property type description <code>body</code> object the object from the bucket in memory; buffer, json or csv object <code>bucket</code> str the name of the bucket <code>id</code> str the id of configuration <code>key</code> str the bucket key <code>name</code> str the name of the event which invoked the lambda <code>object</code> object the object described from the bucket <code>operation</code> str triggered operation lambda (create, delete) <code>region</code> str the region the record is from <code>request</code> object the request parameters <code>response</code> object the response parameters <code>source</code> str the source of the event which invoked the lambda <code>time</code> float the event time <code>version</code> object the s3 schema version"},{"location":"s3/record/#recordregion","title":"<code>record.region</code>","text":"<pre><code>console.log(record.region);\n\n// example output:\n'us-east-2'\n</code></pre>"},{"location":"s3/record/#recordbody","title":"<code>record.body</code>","text":"<pre><code>console.log(record.body);\n\n// example output: depending on the configuration, it might be a Buffer, CSV, or JSON object\n// does require `getObject: true` to be set in the options of the EventClient\n</code></pre>"},{"location":"s3/record/#recordbucket","title":"<code>record.bucket</code>","text":"<pre><code>console.log(record.bucket);\n\n// example output:\n{\n    \"name\": \"DOC-EXAMPLE-BUCKET\",\n    \"ownerIdentity\": {\n        \"principalId\": \"A3I5XTEXAMAI3E\"\n    },\n    \"arn\": \"arn:aws:s3:::lambda-artifacts-deafc19498e3f2df\"\n}\n</code></pre>"},{"location":"s3/record/#recordid","title":"<code>record.id</code>","text":"<pre><code>console.log(record.id);\n\n// example output:\n'828aa6fc-f7b5-4305-8584-487c791949c1'\n</code></pre>"},{"location":"s3/record/#recordname","title":"<code>record.name</code>","text":"<pre><code>console.log(record.name);\n\n// example output:\n'ObjectCreated:Put'\n</code></pre>"},{"location":"s3/record/#recordsource","title":"<code>record.source</code>","text":"<pre><code>console.log(record.source);\n\n// example output:\n'aws:s3'\n</code></pre>"},{"location":"s3/record/#recordtime","title":"<code>record.time</code>","text":"<pre><code>console.log(record.time);\n\n// example output:\n'2019-09-03T19:37:27.192Z'\n</code></pre>"},{"location":"s3/record/#recordkey","title":"<code>record.key</code>","text":"<pre><code>console.log(record.key);\n\n// example output:\n'some-directory/b21b84d653bb07b05b1e6b33684dc11b.json'\n</code></pre>"},{"location":"s3/record/#recordobject","title":"<code>record.object</code>","text":"<pre><code>console.log(record.object);\n\n// example output:\n{\n    'key': 'some-directory/b21b84d653bb07b05b1e6b33684dc11b.json',\n    'size': 1305107,\n    'eTag': 'b21b84d653bb07b05b1e6b33684dc11b',\n    'sequencer': '0C0F6F405D6ED209E1'\n}\n</code></pre>"},{"location":"s3/record/#recordoperation","title":"<code>record.operation</code>","text":"<pre><code>console.log(record.operation);\n\n// example output:\n'create'\n</code></pre>"},{"location":"s3/record/#recordrequest","title":"<code>record.request</code>","text":"<pre><code>console.log(record.request);\n\n// example output:\n{\n    \"sourceIPAddress\": \"205.255.255.255\"\n}\n</code></pre>"},{"location":"s3/record/#recordresponse","title":"<code>record.response</code>","text":"<pre><code>console.log(record.response);\n\n// example output:\n{\n    \"x-amz-request-id\": \"D82B88E5F771F645\",\n    \"x-amz-id-2\": \"vlR7PnpV2Ce81l0PRw6jlUpck7Jo5ZsQjryTjKlc5aLWGVHPZLj5NeC6qMa0emYBDXOo6QBU0Wo=\"\n}\n</code></pre>"},{"location":"s3/record/#recordversion","title":"<code>record.version</code>","text":"<pre><code>console.log(record.version);\n\n// example output:\n\"1.0\"\n</code></pre>"},{"location":"sqs/","title":"SNS/SQS","text":"<p>Event handler for Amazon SNS/SQS Events.</p>"},{"location":"sqs/#features","title":"Features","text":"<ul> <li>Automatically convert JSON from message body</li> <li>Automatically flatten message attributes</li> <li>Able to message body against a JSON Schema</li> <li>Assign Data Classes to records instead of getting record objects</li> </ul>"},{"location":"sqs/configurations/","title":"SNS/SQS Event Configurations","text":"<p>The SNS/SQS event will automatically handle many common things done when eventing off an SNS/SQS stream. Developers then have the ability to further extend that functionality with custom middleware. Below is a full list of all the configurations available and examples of their use.</p> Examples <p>Don't like reading documentation? Then look at our examples, which can be deployed in 1 command into your AWS account! </p>"},{"location":"sqs/configurations/#configuration-options","title":"Configuration Options","text":"option type required default description <code>before</code> func no null a custom function to be ran before your records are pulled <code>dataClass</code> class no null a custom class that will be passed instead of the records object <code>globalLogger</code> bool no false will assign the Acai logger to the global variable <code>globalLogger</code> <code>requiredBody</code> str or obj no null will validate body of record against this schema <code>schemaPath</code> str no null file path pointing to the location of the openapi.yml file <code>validationError</code> bool no false will raise exception if validation of record fails"},{"location":"sqs/configurations/#example-snssqs-configuration-options","title":"Example: SNS/SQS Configuration Options","text":"<pre><code>import { SQSEvent } from 'aws-lambda';\nimport { Event } from 'acai-ts';\nimport { Grower } from './api/logic/grower';\n\nexport const handler = async (event: SQSEvent): Promise&lt;void&gt; =&gt; {\n    const options = {\n        globalLogger: true,\n        requiredBody: 'sqs-record',\n        schemaPath: 'api/openapi.yml',\n        validationError: false, // will raise exception if validation fails;  default false\n        dataClass: Grower, // will get instance of this instead of record instance\n        before: (records: any[]) =&gt; {\n            // run this before records are sent\n        }\n    };\n    const eventClient = new Event.sqs(event, options);\n    const records = await eventClient.getRecords();\n    for (const grower of records) {\n        // do stuff here\n    }\n};\n</code></pre>"},{"location":"sqs/record/","title":"SNS/SQS Record Object","text":"<p>The SNS/SQS event will by default provide instances of <code>record</code> classes which will be easier to work with then a standard lambda event record object. This is the same object which will be passed down to the <code>dataClass</code>, if you provide on in your configuration. Below is a list of all the properties and example outputs for the SNS/SQS event record:</p> Examples <p>Don't like reading documentation? Then look at our examples, which can be deployed in 1 command into your AWS account! </p>"},{"location":"sqs/record/#record-properties","title":"Record Properties","text":"property type description <code>attributes</code> object the attributes of the message <code>body</code> object the object from the bucket in memory; decodes json automatically <code>id</code> str the id of message <code>md5</code> str the message in an md4 hash format <code>messageAttributes</code> object the attributes of the message, flattened <code>raw</code> any the body of the message as is, no conversion <code>receiptHandle</code> str the handle of the receipt <code>region</code> str the region of the message <code>source</code> str the source of the event which invoked the lambda <code>sourceARN</code> str the arn of the source"},{"location":"sqs/record/#recordattributes","title":"<code>record.attributes</code>","text":"<pre><code>console.log(record.attributes);\n\n// example output:\n{\n    \"ApproximateReceiveCount\": \"1\",\n    \"SentTimestamp\": \"1545082650636\",\n    \"SenderId\": \"AIDAIENQZJOLO23YVJ4VO\",\n    \"ApproximateFirstReceiveTimestamp\": \"1545082650649\"\n}\n</code></pre>"},{"location":"sqs/record/#recordbody","title":"<code>record.body</code>","text":"<pre><code>console.log(record.body);\n\n// example output:\n{\n    some_key: 'some_value'\n}\n</code></pre>"},{"location":"sqs/record/#recordsource","title":"<code>record.source</code>","text":"<pre><code>console.log(record.source);\n\n// example output:\n'aws:sqs'\n</code></pre>"},{"location":"sqs/record/#recordmd5","title":"<code>record.md5</code>","text":"<pre><code>console.log(record.md5);\n\n// example output:\n'e4e68fb7bd0e697a0ae8f1bb342846b3'\n</code></pre>"},{"location":"sqs/record/#recordmessageattributes","title":"<code>record.messageAttributes</code>","text":"<pre><code>console.log(record.messageAttributes);\n\n// example output:\n{\n    some_attribute_key: 'some_attribute_value'\n}\n</code></pre>"},{"location":"sqs/record/#recordid","title":"<code>record.id</code>","text":"<pre><code>console.log(record.id);\n\n// example output:\n'2e1424d4-f796-459a-8184-9c92662be6da'\n</code></pre>"},{"location":"sqs/record/#recordraw","title":"<code>record.raw</code>","text":"<pre><code>console.log(record.raw);\n\n// example output:\n'{\"some_key\": \"some_value\"}'\n</code></pre>"},{"location":"sqs/record/#recordreceipthandle","title":"<code>record.receiptHandle</code>","text":"<pre><code>console.log(record.receiptHandle);\n\n// example output:\n'AQEBzWwaftRI0KuVm4tP+/7q1rGgNqicHq...'\n</code></pre>"},{"location":"sqs/record/#recordregion","title":"<code>record.region</code>","text":"<pre><code>console.log(record.region);\n\n// example output:\n'us-east-2'\n</code></pre>"},{"location":"sqs/record/#recordsourcearn","title":"<code>record.sourceARN</code>","text":"<pre><code>console.log(record.sourceARN);\n\n// example output:\n'arn:aws:sqs:us-east-2:123456789012:my-queue'\n</code></pre>"}]}