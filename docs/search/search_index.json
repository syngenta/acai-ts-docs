{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83e\uded0 Acai-TS","text":"<p>DRY, configurable, declarative TypeScript library for working with Amazon Web Service Lambdas.</p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>Highly configurable APIGateway internal router with decorator support</li> <li>OpenAPI schema adherence for all event types</li> <li>Extensible and customizable middleware for validation and other tasks</li> <li>DRY coding interfaces without the need of boilerplate</li> <li>Full TypeScript support with comprehensive type definitions</li> <li>Decorator-based routing (@Route, @Validate, @Before, @After, etc.)</li> <li>Pattern-based routing (convention over configuration)</li> <li>Ease-of-use with the serverless framework</li> <li>Local development support</li> <li>Happy Path Programming (See Philosophy below)</li> </ul>"},{"location":"#philosophy","title":"\ud83d\udca1 Philosophy","text":"<p>The Acai-TS philosophy is to provide a DRY, configurable, declarative library for use with Amazon Lambdas, which encourages Happy Path Programming (HPP).</p> <p>Happy Path Programming is an idea in which inputs are all validated before operated on. This ensures code follows the happy path without the need for mid-level, nested exceptions and all the nasty exception handling that comes with that. The library uses layers of customizable middleware options to allow a developer to easily dictate what constitutes a valid input, without nested conditionals, try/catch blocks or other coding blocks which distract from the happy path that covers the majority of that code's intended operation.</p>"},{"location":"#quick-example","title":"\ud83d\ude80 Quick Example","text":"<pre><code>import 'reflect-metadata';\nimport { Router, BaseEndpoint, Before, After, Timeout, Validate, Response, Request } from 'acai-ts';\nimport { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\n\n// File: src/handlers/users.ts\n// The router maps this file to /users based on file structure\n\n// Define middleware\nconst authMiddleware = async (request: Request, response: Response) =&gt; {\n  if (!request.headers.authorization) {\n    response.code = 401;\n    response.setError('auth', 'Unauthorized');\n  }\n};\n\n// Define your endpoint class with method decorators\nexport class UsersEndpoint extends BaseEndpoint {\n  @Before(authMiddleware)\n  @Validate({ requiredBody: 'CreateUserSchema' })\n  @Timeout(5000)\n  async post(request: Request, response: Response): Promise&lt;Response&gt; {\n    // Create user logic\n    response.body = {\n      id: '123',\n      email: request.body.email,\n      name: request.body.name\n    };\n    return response;\n  }\n\n  @Before(authMiddleware)\n  async get(request: Request, response: Response): Promise&lt;Response&gt; {\n    // Get users logic\n    response.body = { users: [] };\n    return response;\n  }\n}\n\n// Lambda handler\nexport const handler = async (\n  event: APIGatewayProxyEvent\n): Promise&lt;APIGatewayProxyResult&gt; =&gt; {\n  const router = new Router({\n    basePath: '/api/v1',\n    routesPath: './src/handlers/**/*.ts',\n    schemaPath: './openapi.yml' // Optional: OpenAPI validation\n  });\n\n  return await router.route(event);\n};\n</code></pre>"},{"location":"#typescript-first","title":"\ud83d\udcd8 TypeScript First","text":"<p>Acai-TS is the TypeScript evolution of acai-js, built from the ground up with type safety and modern TypeScript features in mind.</p>"},{"location":"changes/","title":"\ud83d\udd04 Migration Guide: acai-js to acai-ts","text":"<p>Acai-TS is a complete TypeScript rewrite of acai-js with improved type safety, decorator support, and modern ES6+ features. This guide will help you migrate your existing acai-js code to acai-ts.</p> Quick Start <p>The main changes are:</p> <ol> <li>Install <code>acai-ts</code> and <code>reflect-metadata</code></li> <li>Convert JavaScript to TypeScript</li> <li>Update imports to use ES6 modules</li> <li>Add type annotations</li> <li>Use decorators for cleaner endpoint definitions (optional)</li> </ol>"},{"location":"changes/#installation-changes","title":"\ud83d\udce6 Installation Changes","text":""},{"location":"changes/#before-acai-js","title":"Before (acai-js)","text":"<pre><code>npm install acai-js\n</code></pre>"},{"location":"changes/#after-acai-ts","title":"After (acai-ts)","text":"<pre><code>npm install acai-ts reflect-metadata\n</code></pre> <p>New Requirements: - Node.js &gt;= 18.18.2 - TypeScript &gt;= 5.0 - <code>reflect-metadata</code> package (for decorator support)</p>"},{"location":"changes/#import-changes","title":"\ud83d\udcc2 Import Changes","text":""},{"location":"changes/#before-acai-js_1","title":"Before (acai-js)","text":"<pre><code>const { Router, Event } = require('acai-js');\n</code></pre>"},{"location":"changes/#after-acai-ts_1","title":"After (acai-ts)","text":"<pre><code>import 'reflect-metadata';\nimport { Router, Event } from 'acai-ts';\nimport { APIGatewayProxyEvent, DynamoDBStreamEvent } from 'aws-lambda';\n</code></pre>"},{"location":"changes/#typescript-configuration","title":"\ud83d\udd27 TypeScript Configuration","text":"<p>Add to your <code>tsconfig.json</code>:</p> <pre><code>{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"target\": \"ES2020\",\n    \"module\": \"commonjs\",\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true\n  }\n}\n</code></pre>"},{"location":"changes/#apigateway-router-changes","title":"\ud83c\udf10 APIGateway Router Changes","text":""},{"location":"changes/#before-acai-js_2","title":"Before (acai-js)","text":"<pre><code>const { Router } = require('acai-js');\n\nexports.handler = async (event) =&gt; {\n  const router = new Router({\n    basePath: '/api/v1',\n    schemaPath: './openapi.yml'\n  });\n\n  return await router.route(event);\n};\n</code></pre>"},{"location":"changes/#after-acai-ts_2","title":"After (acai-ts)","text":"<pre><code>import 'reflect-metadata';\nimport { Router } from 'acai-ts';\nimport { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\n\nexport const handler = async (\n  event: APIGatewayProxyEvent\n): Promise&lt;APIGatewayProxyResult&gt; =&gt; {\n  const router = new Router({\n    basePath: '/api/v1',\n    schemaPath: './openapi.yml'\n  });\n\n  return await router.route(event);\n};\n</code></pre>"},{"location":"changes/#endpoint-changes","title":"\ud83c\udfaf Endpoint Changes","text":""},{"location":"changes/#pattern-based-file-based-routing","title":"Pattern-Based (File-Based) Routing","text":""},{"location":"changes/#before-acai-js_3","title":"Before (acai-js)","text":"<pre><code>// users.js\nexports.requirements = {\n  post: {\n    requiredBody: 'CreateUserRequest'\n  }\n};\n\nexports.post = async (request, response) =&gt; {\n  response.body = { id: '123', ...request.body };\n  return response;\n};\n</code></pre>"},{"location":"changes/#after-acai-ts_3","title":"After (acai-ts)","text":"<pre><code>// users.ts\nimport { Request, Response } from 'acai-ts';\n\nexport const requirements = {\n  post: {\n    requiredBody: 'CreateUserRequest'\n  }\n};\n\nexport const post = async (\n  request: Request, \n  response: Response\n): Promise&lt;Response&gt; =&gt; {\n  response.body = { id: '123', ...request.body };\n  return response;\n};\n</code></pre>"},{"location":"changes/#decorator-based-routing-new-in-acai-ts","title":"\ud83c\udfa8 Decorator-Based Routing (NEW in acai-ts!)","text":"<pre><code>// File: src/handlers/users.ts\nimport { BaseEndpoint, Validate, Response, Request } from 'acai-ts';\n\nexport class UsersEndpoint extends BaseEndpoint {\n  @Validate({ requiredBody: 'CreateUserRequest' })\n  async post(request: Request, response: Response): Promise&lt;Response&gt; {\n    response.body = { id: '123', ...request.body };\n    return response;\n  }\n}\n</code></pre>"},{"location":"changes/#event-handler-changes","title":"\ud83d\uddc3\ufe0f Event Handler Changes","text":""},{"location":"changes/#dynamodb-streams","title":"\ud83d\udcca DynamoDB Streams","text":""},{"location":"changes/#before-acai-js_4","title":"Before (acai-js)","text":"<pre><code>const { Event } = require('acai-js');\n\nexports.handler = async (event) =&gt; {\n  const dynamodb = new Event(event, {\n    operations: ['INSERT', 'MODIFY']\n  });\n\n  for (const record of dynamodb.records) {\n    console.log(record.newImage);\n  }\n};\n</code></pre>"},{"location":"changes/#after-acai-ts_4","title":"After (acai-ts)","text":"<pre><code>import { Event } from 'acai-ts';\nimport { DynamoDBStreamEvent } from 'aws-lambda';\n\nexport const handler = async (event: DynamoDBStreamEvent): Promise&lt;void&gt; =&gt; {\n  const dynamodb = new Event(event, {\n    operations: ['INSERT', 'MODIFY']\n  });\n\n  for (const record of dynamodb.records) {\n    console.log(record.newImage);\n  }\n};\n</code></pre>"},{"location":"changes/#s3-events","title":"\ud83e\ude23 S3 Events","text":""},{"location":"changes/#before-acai-js_5","title":"Before (acai-js)","text":"<pre><code>const { Event } = require('acai-js');\n\nexports.handler = async (event) =&gt; {\n  const s3Event = new Event(event, {\n    getObject: true,\n    isJSON: true\n  });\n\n  await s3Event.process();\n\n  for (const record of s3Event.records) {\n    console.log(record.body);\n  }\n};\n</code></pre>"},{"location":"changes/#after-acai-ts_5","title":"After (acai-ts)","text":"<pre><code>import { Event } from 'acai-ts';\nimport { S3Event } from 'aws-lambda';\n\nexport const handler = async (event: S3Event): Promise&lt;void&gt; =&gt; {\n  const s3Event = new Event(event, {\n    getObject: true,\n    isJSON: true\n  });\n\n  await s3Event.process();\n\n  for (const record of s3Event.records) {\n    console.log(record.body);\n  }\n};\n</code></pre>"},{"location":"changes/#sqs-messages","title":"\ud83d\udcec SQS Messages","text":""},{"location":"changes/#before-acai-js_6","title":"Before (acai-js)","text":"<pre><code>const { Event } = require('acai-js');\n\nexports.handler = async (event) =&gt; {\n  const sqsEvent = new Event(event);\n\n  for (const record of sqsEvent.records) {\n    console.log(record.body);\n  }\n};\n</code></pre>"},{"location":"changes/#after-acai-ts_6","title":"After (acai-ts)","text":"<pre><code>import { Event } from 'acai-ts';\nimport { SQSEvent } from 'aws-lambda';\n\nexport const handler = async (event: SQSEvent): Promise&lt;void&gt; =&gt; {\n  const sqsEvent = new Event(event);\n\n  for (const record of sqsEvent.records) {\n    console.log(record.body);\n  }\n};\n</code></pre>"},{"location":"changes/#logger-changes","title":"\ud83d\udcdd Logger Changes","text":""},{"location":"changes/#before-acai-js_7","title":"Before (acai-js)","text":"<pre><code>global.logger.info('message');\nglobal.logger.error('error');\n</code></pre>"},{"location":"changes/#after-acai-ts_7","title":"After (acai-ts)","text":"<pre><code>import { Logger } from 'acai-ts';\n\nLogger.info('message');\nLogger.error('error');\n</code></pre>"},{"location":"changes/#new-features-in-acai-ts","title":"\u2728 New Features in acai-ts","text":""},{"location":"changes/#1-decorator-support","title":"1\ufe0f\u20e3 Decorator Support","text":"<p>Use decorators for cleaner endpoint definitions:</p> <pre><code>// File: src/handlers/users.ts\nimport { BaseEndpoint, Validate, Before, After, Timeout, Request, Response } from 'acai-ts';\n\nconst authMiddleware = async (request: Request, response: Response) =&gt; {\n  // Auth logic\n};\n\nconst loggingMiddleware = async (request: Request, response: Response) =&gt; {\n  // Logging logic\n};\n\nexport class UsersEndpoint extends BaseEndpoint {\n  @Validate({ requiredBody: 'CreateUserRequest' })\n  @Before(authMiddleware)\n  @After(loggingMiddleware)\n  @Timeout(30000)\n  async post(request: Request, response: Response): Promise&lt;Response&gt; {\n    // Clean business logic\n    response.body = { id: '123', ...request.body };\n    return response;\n  }\n}\n</code></pre>"},{"location":"changes/#2-full-typescript-type-safety","title":"2\ufe0f\u20e3 Full TypeScript Type Safety","text":"<p>All classes, interfaces, and functions are fully typed:</p> <pre><code>import { Request, Response } from 'acai-ts';\n\nconst request: Request = {\n  path: '/users',\n  method: 'POST',\n  body: { email: 'user@example.com' },\n  headers: {},\n  queryParameters: {},\n  pathParameters: {}\n};\n</code></pre>"},{"location":"changes/#3-custom-data-classes-with-types","title":"3\ufe0f\u20e3 Custom Data Classes with Types","text":"<pre><code>interface UserData {\n  id: string;\n  email: string;\n}\n\nclass User {\n  id: string;\n  email: string;\n\n  constructor(record: any) {\n    this.id = record.body.id;\n    this.email = record.body.email;\n  }\n\n  sendWelcomeEmail(): void {\n    // Type-safe method\n  }\n}\n\nconst dynamodb = new Event&lt;User&gt;(event, {\n  dataClass: User,\n  operations: ['INSERT']\n});\n\nfor (const user of dynamodb.records) {\n  user.sendWelcomeEmail(); // Fully typed!\n}\n</code></pre>"},{"location":"changes/#4-improved-error-handling","title":"4\ufe0f\u20e3 Improved Error Handling","text":"<pre><code>import { ApiError } from 'acai-ts';\n\nthrow new ApiError('User not found', 404, 'user_id');\n</code></pre>"},{"location":"changes/#api-compatibility","title":"\ud83d\udd01 API Compatibility","text":"<p>Most APIs remain compatible, but with added type safety:</p> acai-js acai-ts Notes <code>Router</code> <code>Router</code> Same API, now typed <code>Event</code> <code>Event</code> Same API, now typed <code>Request</code> <code>RequestClient</code> / <code>Request</code> Typed interface <code>Response</code> <code>ResponseClient</code> / <code>Response</code> Typed interface <code>global.logger</code> <code>Logger</code> Import from package"},{"location":"changes/#breaking-changes","title":"\u26a0\ufe0f Breaking Changes","text":""},{"location":"changes/#1-package-name","title":"1. Package Name","text":"<ul> <li>Old: <code>acai-js</code> or <code>@syngenta-digital/Acai</code></li> <li>New: <code>acai-ts</code></li> </ul>"},{"location":"changes/#2-nodejs-version","title":"2. Node.js Version","text":"<ul> <li>Old: Node 10.10+</li> <li>New: Node 18.18.2+</li> </ul>"},{"location":"changes/#3-file-extensions","title":"3. File Extensions","text":"<ul> <li>Old: <code>.js</code> files</li> <li>New: <code>.ts</code> files</li> </ul>"},{"location":"changes/#4-export-syntax","title":"4. Export Syntax","text":"<ul> <li>Old: <code>exports.handler</code></li> <li>New: <code>export const handler</code></li> </ul>"},{"location":"changes/#5-import-syntax","title":"5. Import Syntax","text":"<ul> <li>Old: <code>require()</code></li> <li>New: <code>import</code> statements</li> </ul>"},{"location":"changes/#migration-checklist","title":"\u2705 Migration Checklist","text":"<ul> <li>[ ] Install <code>acai-ts</code> and <code>reflect-metadata</code></li> <li>[ ] Update <code>tsconfig.json</code> with decorator support</li> <li>[ ] Convert <code>.js</code> files to <code>.ts</code></li> <li>[ ] Change <code>require()</code> to <code>import</code> statements</li> <li>[ ] Change <code>exports.</code> to <code>export const</code></li> <li>[ ] Add AWS Lambda event types</li> <li>[ ] Add type annotations to functions</li> <li>[ ] Update <code>acai-js</code> imports to <code>acai-ts</code></li> <li>[ ] Add <code>import 'reflect-metadata'</code> at entry points</li> <li>[ ] Test all endpoints and event handlers</li> <li>[ ] Update deployment configuration for TypeScript build</li> </ul>"},{"location":"changes/#need-help","title":"\ud83c\udd98 Need Help?","text":"<ul> <li>GitHub Issues</li> <li>Examples Repository</li> <li>API Documentation</li> </ul>"},{"location":"demo/","title":"\ud83c\udfaa Demo &amp; Explanation of Acai-TS","text":""},{"location":"demo/#examples-repository","title":"\ud83d\udcda Examples Repository","text":"<p>Don't like reading documentation? Check out our working examples:</p> Working Examples <p>All examples are located in the examples directory of this repository.</p> <ul> <li>APIGateway with Decorators - Full decorator-based routing example</li> <li>APIGateway with Pattern Routing - Convention over configuration example</li> <li>DynamoDB Streams - Process DynamoDB stream events</li> <li>S3 Events - Process S3 bucket events</li> <li>SQS Messages - Process SQS queue messages</li> </ul>"},{"location":"demo/#quick-start-tutorial","title":"\ud83d\ude80 Quick Start Tutorial","text":""},{"location":"demo/#1-install-acai-ts","title":"1\ufe0f\u20e3 Install Acai-TS","text":"<pre><code>npm install acai-ts reflect-metadata\n</code></pre>"},{"location":"demo/#2-create-your-first-endpoint","title":"2\ufe0f\u20e3 Create Your First Endpoint","text":"<pre><code>import 'reflect-metadata';\nimport { Router, BaseEndpoint, Response, Request } from 'acai-ts';\nimport { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\n\n// File: src/handlers/hello.ts\nexport class HelloEndpoint extends BaseEndpoint {\n  async get(request: Request, response: Response): Promise&lt;Response&gt; {\n    response.body = { message: 'Hello, World!' };\n    return response;\n  }\n}\n\nexport const handler = async (\n  event: APIGatewayProxyEvent\n): Promise&lt;APIGatewayProxyResult&gt; =&gt; {\n  const router = new Router({\n    basePath: '/api/v1',\n    routesPath: './src/handlers/**/*.ts'\n  });\n\n  return await router.route(event);\n};\n</code></pre>"},{"location":"demo/#3-add-schema-validation","title":"3\ufe0f\u20e3 Add Schema Validation","text":"<pre><code>// File: src/handlers/users.ts\nimport { BaseEndpoint, Validate, Response, Request } from 'acai-ts';\n\nexport class UsersEndpoint extends BaseEndpoint {\n  @Validate({ requiredBody: 'CreateUserRequest' })\n  async post(request: Request, response: Response): Promise&lt;Response&gt; {\n    // request.body is already validated against your OpenAPI schema\n    response.body = { \n      id: '123',\n      ...request.body \n    };\n    return response;\n  }\n}\n</code></pre>"},{"location":"demo/#4-add-middleware","title":"4\ufe0f\u20e3 Add Middleware","text":"<pre><code>// File: src/handlers/profile.ts\nimport { BaseEndpoint, Before, Response, Request } from 'acai-ts';\n\nconst authMiddleware = async (request: Request, response: Response) =&gt; {\n  if (!request.headers.authorization) {\n    response.code = 401;\n    response.setError('auth', 'Unauthorized');\n  }\n};\n\nexport class ProfileEndpoint extends BaseEndpoint {\n  @Before(authMiddleware)\n  async get(request: Request, response: Response): Promise&lt;Response&gt; {\n    response.body = { user: 'profile data' };\n    return response;\n  }\n}\n</code></pre>"},{"location":"demo/#key-concepts","title":"\ud83d\udca1 Key Concepts","text":""},{"location":"demo/#happy-path-programming","title":"\ud83c\udf86 Happy Path Programming","text":"<p>Acai-TS embraces Happy Path Programming - validation happens upfront, so your business logic runs cleanly:</p> <pre><code>// \u274c Without Acai-TS: Defensive coding everywhere\nexport const handler = async (event: any) =&gt; {\n  try {\n    if (!event.body) throw new Error('No body');\n    const body = JSON.parse(event.body);\n    if (!body.email) throw new Error('Email required');\n    // Finally, business logic...\n  } catch (error) {\n    return { statusCode: 400, body: JSON.stringify({ error }) };\n  }\n};\n\n// \u2705 With Acai-TS: Validation handled, focus on logic\nexport class CreateUserEndpoint extends BaseEndpoint {\n  @Validate({ requiredBody: 'CreateUserRequest' })\n  async post(request: Request, response: Response): Promise&lt;Response&gt; {\n    // Body is already validated - just write business logic!\n    const user = await this.userService.create(request.body);\n    response.body = user;\n    return response;\n  }\n}\n</code></pre>"},{"location":"demo/#typescript-first","title":"\ud83d\udcd8 TypeScript First","text":"<p>Full type safety throughout:</p> <pre><code>interface User {\n  id: string;\n  email: string;\n  name: string;\n}\n\n// File: src/handlers/users/{id}.ts\nexport class UserEndpoint extends BaseEndpoint {\n  async get(request: Request, response: Response): Promise&lt;Response&gt; {\n    const userId: string = request.pathParameters.id;\n    const user: User = await this.userRepo.findById(userId);\n\n    response.body = user; // Fully typed!\n    return response;\n  }\n}\n</code></pre>"},{"location":"demo/#next-steps","title":"\ud83d\udccd Next Steps","text":"<ul> <li>APIGateway Documentation - Learn about routing, decorators, and request/response handling</li> <li>DynamoDB Events - Process DynamoDB stream events</li> <li>S3 Events - Process S3 bucket events  </li> <li>SQS Events - Process SQS queue messages</li> </ul>"},{"location":"install/","title":"\ud83d\udce6 Installation","text":""},{"location":"install/#requirements","title":"\u26a1 Requirements","text":"<ul> <li>Node.js 18.18.2 or higher; download and install Node.js</li> <li>TypeScript 5.0 or higher</li> <li>Access to public npm registry</li> </ul>"},{"location":"install/#installation_1","title":"\ud83d\ude80 Installation","text":"npm <pre><code>npm install acai-ts\n</code></pre> yarn <pre><code>yarn add acai-ts\n</code></pre> pnpm <pre><code>pnpm add acai-ts\n</code></pre> <p>Note: <code>reflect-metadata</code> is automatically installed as a dependency of <code>acai-ts</code>.</p>"},{"location":"install/#typescript-configuration","title":"\ud83d\udd27 TypeScript Configuration","text":"<p>Acai-TS requires the following TypeScript compiler options in your <code>tsconfig.json</code>:</p> <pre><code>{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"target\": \"ES2020\",\n    \"module\": \"commonjs\",\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true\n  }\n}\n</code></pre>"},{"location":"install/#import-reflect-metadata","title":"\ud83d\udccb Import Reflect Metadata","text":"<p>You must import <code>reflect-metadata</code> at the entry point of your application when using decorators:</p> <pre><code>import 'reflect-metadata';\nimport { Router, BaseEndpoint } from 'acai-ts';\n\n// Your code here...\n</code></pre> <p>Important: While <code>reflect-metadata</code> is automatically installed with <code>acai-ts</code>, you still need to explicitly import it in your code for decorator support to work.</p>"},{"location":"install/#verify-installation","title":"\u2705 Verify Installation","text":"<p>Create a simple test file to verify the installation:</p> <pre><code>import 'reflect-metadata';\nimport { Router } from 'acai-ts';\n\nconst router = new Router({\n  basePath: '/api/v1'\n});\n\nconsole.log('Acai-TS installed successfully!');\n</code></pre>"},{"location":"troubleshooting/","title":"\ud83d\udd0d Troubleshooting","text":"<p>This guide covers common issues you may encounter when using acai-ts and their solutions.</p>"},{"location":"troubleshooting/#route-resolution-issues","title":"\ud83d\udee3\ufe0f Route Resolution Issues","text":""},{"location":"troubleshooting/#routepath-differences-between-development-and-build","title":"\ud83c\udfed routePath Differences Between Development and Build","text":"<p>Problem: Routes work in development but fail in production builds, or vice versa.</p> <p>Symptoms: - Routes return 404 errors in production - Path parameters are not correctly parsed - Route matching behaves differently between local development and deployed environments</p> <p>Causes: - File path resolution differences between development and compiled code - TypeScript compilation changing file structure - Serverless packaging affecting route discovery</p> <p>Solutions:</p>"},{"location":"troubleshooting/#1-use-absolute-paths-in-router-configuration","title":"1\ufe0f\u20e3 Use Absolute Paths in Router Configuration","text":"<pre><code>// \u274c Problematic - relative paths\nconst router = new Router({\n  mode: 'directory',\n  routesPath: './api/handlers'\n});\n\n// \u2705 Better - absolute paths from project root\nconst router = new Router({\n  mode: 'directory',\n  routesPath: path.join(__dirname, '../api/handlers')\n});\n</code></pre>"},{"location":"troubleshooting/#2-verify-build-output-structure","title":"2\ufe0f\u20e3 Verify Build Output Structure","text":"<p>Check that your build process preserves the expected file structure:</p> <pre><code># Check your dist/build directory structure\nfind dist -name \"*.js\" -type f | head -10\n\n# Ensure route files are in expected locations\nls -la dist/api/handlers/\n</code></pre>"},{"location":"troubleshooting/#3-use-explicit-route-lists-for-production","title":"3\ufe0f\u20e3 Use Explicit Route Lists for Production","text":"<p>For maximum reliability in production:</p> <pre><code>const router = new Router({\n  mode: 'list',\n  routes: [\n    { method: 'GET', path: '/users', handler: 'dist/api/handlers/users.js' },\n    { method: 'POST', path: '/users', handler: 'dist/api/handlers/users.js' },\n    { method: 'GET', path: '/users/:id', handler: 'dist/api/handlers/users/[id].js' }\n  ]\n});\n</code></pre>"},{"location":"troubleshooting/#4-environment-specific-configuration","title":"4\ufe0f\u20e3 Environment-Specific Configuration","text":"<pre><code>const isDevelopment = process.env.NODE_ENV === 'development';\n\nconst router = new Router({\n  mode: 'directory',\n  routesPath: isDevelopment \n    ? 'src/api/handlers'\n    : path.join(__dirname, 'api/handlers'),\n  basePath: isDevelopment ? '' : '/api/v1'\n});\n</code></pre>"},{"location":"troubleshooting/#5-debug-route-discovery","title":"5\ufe0f\u20e3 Debug Route Discovery","text":"<p>Enable logging to see which routes are being discovered:</p> <pre><code>const router = new Router({\n  mode: 'pattern',\n  routesPath: 'api/**/*.js',\n  outputError: true, // Enable error output\n  globalLogger: true // Enable detailed logging\n});\n\n// Add custom logging\nrouter.autoLoad();\nconsole.log('Discovered routes:', router.getRoutes?.());\n</code></pre>"},{"location":"troubleshooting/#decorator-issues","title":"\ud83c\udfa8 Decorator Issues","text":""},{"location":"troubleshooting/#reflect-metadata-not-found","title":"\ud83e\ude9e Reflect Metadata Not Found","text":"<p>Problem: <code>Cannot read property 'getMetadata' of undefined</code> or similar metadata errors.</p> <p>Solution: <pre><code>// \u2705 Must be imported FIRST, before any decorators\nimport 'reflect-metadata';\nimport { Route, Validate } from 'acai-ts';\n\n// Rest of your code...\n</code></pre></p>"},{"location":"troubleshooting/#typescript-configuration-issues","title":"\ud83d\udd27 TypeScript Configuration Issues","text":"<p>Problem: Decorators not working or compiler errors.</p> <p>Solution: Ensure your <code>tsconfig.json</code> has the correct settings:</p> <pre><code>{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"target\": \"ES2020\",\n    \"module\": \"commonjs\",\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"strict\": true\n  }\n}\n</code></pre>"},{"location":"troubleshooting/#decorator-order-issues","title":"\ud83d\udd22 Decorator Order Issues","text":"<p>Problem: Middleware not executing in expected order.</p> <p>Solution: Understand the execution order:</p> <pre><code>export class UserController {\n  // Execution order:\n  @Route('POST', '/users')    // 1. Route definition\n  @Auth(authFunction)         // 2. Authentication (executed first)\n  @Validate(schema)           // 3. Validation (executed second)\n  @Before(beforeMiddleware)   // 4. Before middleware (executed third)\n  @After(afterMiddleware)     // 6. After middleware (executed after handler)\n  @Timeout(5000)              // Applied throughout entire request\n  async createUser(...) {     // 5. Handler function\n    // Your code here\n  }\n}\n</code></pre>"},{"location":"troubleshooting/#method-not-found-errors","title":"\u274c Method Not Found Errors","text":"<p>Problem: <code>Method not found</code> or handler not being called.</p> <p>Common Causes &amp; Solutions:</p>"},{"location":"troubleshooting/#1-method-name-mismatch","title":"1\ufe0f\u20e3 Method Name Mismatch","text":"<pre><code>// \u274c Wrong - method name doesn't match decorator\n@Route('POST', '/users')\nasync getUser() {} // Method name suggests GET but decorator says POST\n\n// \u2705 Correct - clear method names\n@Route('POST', '/users')\nasync createUser() {}\n\n@Route('GET', '/users/:id')\nasync getUser() {}\n</code></pre>"},{"location":"troubleshooting/#2-missing-export","title":"2\ufe0f\u20e3 Missing Export","text":"<pre><code>// \u274c Wrong - not exported\n@Route('GET', '/users')\nasync getUsers() {}\n\n// \u2705 Correct - properly exported\nexport class UserController {\n  @Route('GET', '/users')\n  async getUsers() {}\n}\n</code></pre>"},{"location":"troubleshooting/#3-router-not-recognizing-decorated-routes","title":"3\ufe0f\u20e3 Router Not Recognizing Decorated Routes","text":"<pre><code>// Make sure your router is configured correctly for decorators\nconst router = new Router({\n  mode: 'list',\n  routes: [], // Empty array - routes come from decorators\n  // ... other config\n});\n\n// And that you're importing decorated classes somewhere\nimport './controllers/UserController'; // This registers the decorated routes\n</code></pre>"},{"location":"troubleshooting/#validation-issues","title":"\u2713 Validation Issues","text":""},{"location":"troubleshooting/#schema-validation-failures","title":"\ud83d\udea8 Schema Validation Failures","text":"<p>Problem: Valid requests are being rejected or invalid requests are passing.</p> <p>Debug Steps:</p> <ol> <li> <p>Check Schema Syntax: <pre><code>// \u2705 Correct JSON Schema\n@Validate({\n  body: {\n    type: 'object',\n    required: ['name', 'email'],\n    properties: {\n      name: { type: 'string', minLength: 1 },\n      email: { type: 'string', format: 'email' }\n    }\n  }\n})\n\n// \u274c Common mistake - wrong schema structure\n@Validate({\n  name: { type: 'string' }, // Missing 'body' wrapper\n  email: { type: 'string' }\n})\n</code></pre></p> </li> <li> <p>Enable Validation Logging: <pre><code>const router = new Router({\n  // ... other config\n  outputError: true, // Show detailed validation errors\n  validateResponse: true // Also validate responses\n});\n</code></pre></p> </li> <li> <p>Test Schema Separately: <pre><code>import { Validator } from 'acai-ts';\n\nconst validator = new Validator();\nconst schema = { /* your schema */ };\nconst data = { /* your test data */ };\n\nconst result = validator.validate(data, schema);\nconsole.log('Validation result:', result);\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#openapi-validation-issues","title":"\ud83d\udcc4 OpenAPI Validation Issues","text":"<p>Problem: Router with <code>autoValidate: true</code> not working correctly.</p> <p>Solution: <pre><code>const router = new Router({\n  mode: 'directory',\n  routesPath: 'api/handlers',\n  autoValidate: true,\n  schemaPath: './openapi.yml', // Make sure this path is correct\n  validateResponse: false // Set to true only if you have response schemas\n});\n</code></pre></p> <p>Verify your OpenAPI schema: - Paths match your route structure exactly - HTTP methods are correctly defined - Request/response schemas are valid JSON Schema</p>"},{"location":"troubleshooting/#performance-issues","title":"\u26a1 Performance Issues","text":""},{"location":"troubleshooting/#slow-route-resolution","title":"\ud83d\udc22 Slow Route Resolution","text":"<p>Problem: First request takes a long time or timeouts occur.</p> <p>Solutions:</p> <ol> <li> <p>Use <code>autoLoad()</code> for Better Cold Start Performance: <pre><code>const router = new Router({\n  mode: 'directory',\n  routesPath: 'api/handlers'\n});\n\n// Pre-load routes during Lambda initialization\nrouter.autoLoad();\n\nexport const handler = async (event) =&gt; {\n  return router.route(event);\n};\n</code></pre></p> </li> <li> <p>Optimize File Discovery: <pre><code>// \u2705 Specific patterns perform better\nconst router = new Router({\n  mode: 'pattern',\n  routesPath: 'api/handlers/**/*.controller.js' // Specific pattern\n});\n\n// \u274c Avoid overly broad patterns\nconst router = new Router({\n  mode: 'pattern',\n  routesPath: '**/*.js' // Too broad, scans entire project\n});\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#memory-issues-with-large-applications","title":"\ud83d\udcbe Memory Issues with Large Applications","text":"<p>Problem: High memory usage or out-of-memory errors.</p> <p>Solutions:</p> <ol> <li> <p>Use Targeted Route Loading: <pre><code>// Instead of loading all routes, be selective\nconst router = new Router({\n  mode: 'list',\n  routes: [\n    // Only include routes you actually need\n    { method: 'GET', path: '/users', handler: 'handlers/users.js' }\n  ]\n});\n</code></pre></p> </li> <li> <p>Avoid Loading Heavy Dependencies in Route Files: <pre><code>// \u274c Heavy imports loaded for all routes\nimport * as AWS from 'aws-sdk';\nimport * as heavyLibrary from 'heavy-library';\n\n@Route('GET', '/users')\nasync getUsers() {\n  // Simple handler that doesn't need heavy libraries\n}\n\n// \u2705 Lazy load heavy dependencies\n@Route('POST', '/process-data')\nasync processData() {\n  const AWS = await import('aws-sdk'); // Lazy load when needed\n  const processor = await import('./heavy-processor');\n  // Use as needed\n}\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#authentication-issues","title":"\ud83d\udd10 Authentication Issues","text":""},{"location":"troubleshooting/#auth-not-blocking-requests","title":"\ud83d\udea8 @Auth Not Blocking Requests","text":"<p>Problem: Authentication decorator allows unauthorized requests through.</p> <p>Common Causes:</p> <ol> <li> <p>Auth Function Not Returning Boolean: <pre><code>// \u274c Wrong - doesn't return boolean\n@Auth(async (request) =&gt; {\n  const user = await validateUser(request);\n  // Missing return statement!\n})\n\n// \u2705 Correct - explicitly returns boolean\n@Auth(async (request) =&gt; {\n  const user = await validateUser(request);\n  return user !== null; // Explicit boolean return\n})\n</code></pre></p> </li> <li> <p>Async Issues: <pre><code>// \u274c Wrong - not awaiting async operations\n@Auth((request) =&gt; {\n  return validateUser(request); // Returns Promise, not boolean!\n})\n\n// \u2705 Correct - properly handling async\n@Auth(async (request) =&gt; {\n  const isValid = await validateUser(request);\n  return isValid;\n})\n</code></pre></p> </li> <li> <p>Exception Handling: <pre><code>// \u2705 Good practice - handle exceptions properly\n@Auth(async (request) =&gt; {\n  try {\n    const user = await validateUser(request);\n    return user !== null;\n  } catch (error) {\n    console.error('Auth error:', error);\n    return false; // Fail closed - deny access on error\n  }\n})\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#build-and-deployment-issues","title":"\ud83d\ude80 Build and Deployment Issues","text":""},{"location":"troubleshooting/#routes-not-found-after-deployment","title":"\ud83d\udd04 Routes Not Found After Deployment","text":"<p>Problem: Routes work locally but return 404 in deployed environment.</p> <p>Solutions:</p> <ol> <li> <p>Check Build Output: <pre><code># Verify your build includes route files\nnpm run build\nfind dist -name \"*.js\" | grep -E \"(route|handler|controller)\"\n</code></pre></p> </li> <li> <p>Verify Serverless Configuration: <pre><code># serverless.yml\nfunctions:\n  api:\n    handler: dist/handler.route  # Make sure path is correct\n    events:\n      - httpApi:\n          path: /{proxy+}\n          method: any\n</code></pre></p> </li> <li> <p>Check File Extensions in Production: <pre><code>// Use correct file extensions for your build output\nconst router = new Router({\n  mode: 'pattern',\n  routesPath: process.env.NODE_ENV === 'production'\n    ? 'dist/**/*.js'    // Built files\n    : 'src/**/*.ts'     // Source files\n});\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#timeout-issues","title":"\u23f0 Timeout Issues","text":"<p>Problem: Functions timing out unexpectedly.</p> <p>Debug Steps:</p> <ol> <li> <p>Check Timeout Configuration: <pre><code>// Function-level timeout\n@Timeout(30000) // 30 seconds\n\n// Router-level default\nconst router = new Router({\n  timeout: 30000 // 30 seconds default\n});\n</code></pre></p> </li> <li> <p>Add Logging to Identify Bottlenecks: <pre><code>@Before(async (request) =&gt; {\n  console.log('Request started:', Date.now());\n})\n\n@After(async (request, response) =&gt; {\n  console.log('Request completed:', Date.now());\n})\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#getting-help","title":"\ud83c\udd98 Getting Help","text":"<p>If you continue to experience issues:</p> <ol> <li> <p>Enable Debug Logging: <pre><code>const router = new Router({\n  globalLogger: true,\n  outputError: true\n});\n</code></pre></p> </li> <li> <p>Check Examples: Review the working examples</p> </li> <li> <p>Create Minimal Reproduction: Strip down to the simplest possible case that demonstrates the issue</p> </li> <li> <p>Check Version Compatibility: Ensure you're using compatible versions of acai-ts, TypeScript, and Node.js</p> </li> </ol> <p>For additional support, please check: - GitHub Issues - NPM Package - Documentation Examples</p>"},{"location":"apigateway/","title":"APIGateway","text":"<p>Event handler for Amazon APIGateway REST &amp; GraphQL.</p>"},{"location":"apigateway/#features","title":"Features","text":"<ul> <li>Configurable router based on 3 common routing patterns</li> <li>Built-in request validation using standard OpenAPI schema</li> <li>Easily validate request in modular and declarative way without any additional code</li> <li>Able to easily extend with custom middleware at both app and per-endpoint levels</li> <li>Support for CORS, binary and Gzip compression</li> <li>Full TypeScript support with type definitions</li> <li>Decorator-based routing with @Route, @Validate, @Before, @After, @Timeout, and @Auth</li> </ul>"},{"location":"apigateway/request/","title":"Request Object","text":"<p>By default, every endpoint function will receive an instance of the <code>RequestClient</code> class (aka <code>request</code>) as the first argument of their function. This <code>request</code> has a lot of properties which will do common things automatically, but still allows the developer to override those operations if they deem necessary. Below is a list and examples of all the properties of the <code>request</code>:</p> Example <p>Don't like reading documentation? Then look at our examples which can run locally!</p>"},{"location":"apigateway/request/#request-properties","title":"Request Properties","text":"property type mutable description <code>method</code> string no the http method of the request <code>resource</code> string no the AWS resource being invoked <code>authorizer</code> object no if using a customized authorizer, the authorizer object <code>headers</code> object no the headers of the request <code>params</code> object no combination of query string and path params in one object <code>queryParams</code> object no query string parameters from the request <code>pathParams</code> object no the path parameters of the request <code>route</code> string no the requested route with placeholders of params <code>path</code> string no the raw requested path with actual param values <code>json</code> object no the body of the request, converted from json string in object <code>xml</code> object no the body of the request, converted from xml string in object <code>graphql</code> string no the body of the graphql request as a string <code>body</code> any no the body of the request, converted to based on data type <code>raw</code> any no the raw body of the request no conversion <code>context</code> object yes mutable request context to assigned and pass around <code>event</code> object no the full event originally coming from the lambda"},{"location":"apigateway/request/#requestmethod","title":"<code>request.method</code>","text":"<pre><code>console.log(request.method);\n\n// example output:\n'get'\n</code></pre>"},{"location":"apigateway/request/#requestresource","title":"<code>request.resource</code>","text":"<pre><code>console.log(request.resource);\n\n// example output:\n'/{proxy+}'\n</code></pre>"},{"location":"apigateway/request/#requestauthorizer","title":"<code>request.authorizer</code>","text":"Tip <p>This is only useful if you are using an external authorizer with your lambda.</p> <pre><code>console.log(request.authorizer);\n\n// example output:\n{\n    apiKey: 'SOME KEY',\n    userId: 'x-1-3-4',\n    correlationId: 'abc12312',\n    principalId: '9de3f415a97e410386dbef146e88744e',\n    integrationLatency: 572\n}\n</code></pre>"},{"location":"apigateway/request/#requestheaders","title":"<code>request.headers</code>","text":"<pre><code>console.log(request.headers);\n\n// example output:\n{\n    'x-api-key': 'SOME-KEY',\n    'content-type': 'application/json'\n}\n</code></pre>"},{"location":"apigateway/request/#requestparams","title":"<code>request.params</code>","text":"Info <p>This combines both path parameters and query string parameters, nested in one object.</p> <pre><code>console.log(request.params);\n\n// example output:\n{\n    query: {\n        name: 'me'\n    },\n    path: {\n        id: 1\n    }\n}\n</code></pre>"},{"location":"apigateway/request/#requestqueryparams","title":"<code>request.queryParams</code>","text":"<pre><code>console.log(request.queryParams);\n\n// example output:\n{\n     name: 'me'\n}\n</code></pre>"},{"location":"apigateway/request/#requestpathparams","title":"<code>request.pathParams</code>","text":"<pre><code>console.log(request.pathParams);\n\n// example output:\n{\n     id: 1\n}\n</code></pre>"},{"location":"apigateway/request/#requestroute","title":"<code>request.route</code>","text":"Info <p>This will provide the route with the path param variables included</p> <pre><code>console.log(request.route);\n\n// example output:\n'grower/{id}'\n</code></pre>"},{"location":"apigateway/request/#requestpath","title":"<code>request.path</code>","text":"Info <p>This will provide the route with the path param values replacing the variables</p> <pre><code>console.log(request.path);\n\n// example output:\n'grower/1'\n</code></pre>"},{"location":"apigateway/request/#requestjson","title":"<code>request.json</code>","text":"Warning <p>This will raise an unhandled exception if the body is not json compatible</p> <pre><code>console.log(request.json);\n\n// example output:\n{\n    someJsonKey: 'someJsonValue'\n}\n</code></pre>"},{"location":"apigateway/request/#requestxml","title":"<code>request.xml</code>","text":"Warning <p>This will raise an unhandled exception if the body is not xml compatible</p> <pre><code>console.log(request.xml);\n\n// example output:\n{\n    someXMLKey: 'someXMLValue'\n}\n</code></pre>"},{"location":"apigateway/request/#requestgraphql","title":"<code>request.graphql</code>","text":"Info <p>This is graphql string since there is no object equivalent; you can pass this directly to your graphql resolver</p> <pre><code>console.log(request.graphql);\n\n// example output:\n'{\n    players {\n        name\n    }\n}'\n</code></pre>"},{"location":"apigateway/request/#requestbody","title":"<code>request.body</code>","text":"Tip <p>This is the safest way to get the body of the request. It will use the <code>content-type</code> header to determine the data sent and convert it; if the data can't be converted for whatever reason it will catch the error and return the raw body provided unconverted.</p> <pre><code>console.log(request.body);\n\n// example output:\n{\n    someXMLKey: 'someXMLValue'\n}\n</code></pre>"},{"location":"apigateway/request/#requestraw","title":"<code>request.raw</code>","text":"<pre><code>console.log(request.raw);\n\n// example output: whatever the raw data of the body is; string, json string, xml, binary, etc\n</code></pre>"},{"location":"apigateway/request/#requestcontext","title":"<code>request.context</code>","text":"Tip <p>This is the only mutable property of the request, to be used by any of the <code>before</code> or <code>beforeAll</code> middleware options</p> <pre><code>request.context = {application_assignable: true}\nconsole.log(request.context);\n\n// example output:\n{\n    application_assignable: true\n}\n</code></pre>"},{"location":"apigateway/request/#requestevent","title":"<code>request.event</code>","text":"Warning <p>This is the original full request. Not advisable to use this as defeats the purpose of the entire Acai. In addition, you don't want to mutate this object and potentially mess up the entire router.</p> <pre><code>import { APIGatewayProxyEventV2 } from 'aws-lambda';\n\nconsole.log(request.event);\n\n// example output:\n{\n    \"version\": \"2.0\",\n    \"routeKey\": \"$default\",\n    \"rawPath\": \"/my/path\",\n    \"rawQueryString\": \"parameter1=value1&amp;parameter1=value2&amp;parameter2=value\",\n    \"cookies\": [\n        \"cookie1\",\n        \"cookie2\"\n    ],\n    \"headers\": {\n        \"header1\": \"value1\",\n        \"header2\": \"value1,value2\"\n    },\n    \"queryStringParameters\": {\n        \"parameter1\": \"value1,value2\",\n        \"parameter2\": \"value\"\n    },\n    \"requestContext\": {\n        \"accountId\": \"123456789012\",\n        \"apiId\": \"api-id\",\n        \"authentication\": {\n            \"clientCert\": {\n                \"clientCertPem\": \"CERT_CONTENT\",\n                \"subjectDN\": \"www.example.com\",\n                \"issuerDN\": \"Example issuer\",\n                \"serialNumber\": \"a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1:a1\",\n                \"validity\": {\n                    \"notBefore\": \"May 28 12:30:02 2019 GMT\",\n                    \"notAfter\": \"Aug  5 09:36:04 2021 GMT\"\n                }\n            }\n        },\n        \"authorizer\": {\n            \"jwt\": {\n                \"claims\": {\n                    \"claim1\": \"value1\",\n                    \"claim2\": \"value2\"\n                },\n                \"scopes\": [\n                    \"scope1\",\n                    \"scope2\"\n                ]\n            }\n        },\n        \"domainName\": \"id.execute-api.us-east-1.amazonaws.com\",\n        \"domainPrefix\": \"id\",\n        \"http\": {\n            \"method\": \"POST\",\n            \"path\": \"/my/path\",\n            \"protocol\": \"HTTP/1.1\",\n            \"sourceIp\": \"IP\",\n            \"userAgent\": \"agent\"\n        },\n        \"requestId\": \"id\",\n        \"routeKey\": \"$default\",\n        \"stage\": \"$default\",\n        \"time\": \"12/Mar/2020:19:03:58 +0000\",\n        \"timeEpoch\": 1583348638390\n    },\n    \"body\": \"Hello from Lambda\",\n    \"pathParameters\": {\n        \"parameter1\": \"value1\"\n    },\n    \"isBase64Encoded\": false,\n    \"stageVariables\": {\n        \"stageVariable1\": \"value1\",\n        \"stageVariable2\": \"value2\"\n    }\n}\n</code></pre>"},{"location":"apigateway/response/","title":"Response Object","text":"<p>By default, every endpoint function will receive an instance of the <code>ResponseClient</code> class (aka <code>response</code>) as the second argument of their function. This response object is meant to provide consistency to HTTP response codes and error signatures. Below is a list and examples of all the properties of the <code>response</code>:</p> Example <p>Don't like reading documentation? Then look at our examples which can run locally!</p>"},{"location":"apigateway/response/#response-properties","title":"Response Properties","text":"property type description <code>headers</code> object provide headers in key/value pairs to add new headers <code>code</code> number http response code to be returned the requester <code>body</code> any body of the response automatically converted to JSON string <code>rawBody</code> any body of the response not converted to JSON string <code>compress</code> boolean will compress the body if set to true and add proper headers <code>setError</code> func function to set an error with a key and value <code>hasError</code> boolean simple property to check if response already has errors in it"},{"location":"apigateway/response/#responseheaders","title":"<code>response.headers</code>","text":"<pre><code>response.headers = {key: 'status', value: 'ok'};\nresponse.headers = {key: 'response_id', value: 'some-guid'};\n\nconsole.log(response.headers);\n\n// example output:\n{\n    status: 'ok',\n    response_id: 'some-guid',\n}\n</code></pre>"},{"location":"apigateway/response/#responsecode","title":"<code>response.code</code>","text":"<pre><code>response.code = 418;\n\nconsole.log(response.code);\n\n// example output:\n418\n</code></pre>"},{"location":"apigateway/response/#responsebody","title":"<code>response.body</code>","text":"Info <p>This will automatically convert the body to json if possible when called.</p> <pre><code>response.body = {someKey: 'someValue'};\n\nconsole.log(response.body);\n\n// example output:\n'{\"someKey\":\"someValue\"}'\n</code></pre>"},{"location":"apigateway/response/#responserawbody","title":"<code>response.rawBody</code>","text":"Info <p>This will NOT automatically convert the body to json if possible when called. This is great when working with an <code>afterAll</code> method that wants to mutate the body of the response before returning to the user.</p> <pre><code>response.rawBody = {someKey: 'someValue'};\n\nconsole.log(response.rawBody);\n\n// example output:\n{\n    someKey: 'someValue'\n}\n</code></pre>"},{"location":"apigateway/response/#responsecompress","title":"<code>response.compress</code>","text":"Info <p>This will compress whatever is in the body property.</p> <pre><code>response.compress = true;\n\nconsole.log(response.body);\n// example output: this will gzip and compress the body.\n</code></pre>"},{"location":"apigateway/response/#responseseterrorkey-value","title":"<code>response.setError(key, value)</code>","text":"<pre><code>const someKey: string = 'abc123';\nresponse.setError('someKey', `${someKey} is not a valid key to use with this service; try again with a different key`);\nconst anotherKey: string = 'def456';\nresponse.setError('anotherKey', `${anotherKey} is not the correct type to operate on`);\n\nconsole.log(response.rawBody);\n\n// example output:\n{\n    errors: [\n        {\n            key_path: 'someKey',\n            message: 'abc123 is not a valid key to use with this service; try again with a different key'\n        },\n        {\n            key_path: 'anotherKey',\n            message: 'def456 is not the correct type to operate on'\n        }\n    ]\n}\n</code></pre>"},{"location":"apigateway/response/#responsehaserror","title":"<code>response.hasError</code>","text":"<pre><code>response.setError('user', `your access is denied`);\nconsole.log(response.hasError);\n\n// example output:\ntrue\n\n\nresponse.body = {user: 'you have been granted access'};\nconsole.log(response.hasError);\n\n// example output:\nfalse\n</code></pre>"},{"location":"apigateway/endpoint/configurations/","title":"Endpoint Configurations","text":"<p>In order to encourage \"Happy Path Programming\" and make it easier for developers to validate request fully, the Acai comes with a host of built-in validations as well as the ability to extend with custom validations and middleware. See the full validation list here:</p> Examples <p>Don't like reading documentation? Then look at our examples, which can run locally!</p>"},{"location":"apigateway/endpoint/configurations/#validation-configurations","title":"Validation Configurations","text":"requirement type description <code>requiredHeaders</code> array every header in this array must be in the headers of request <code>availableHeaders</code> array only headers in this array will be allowed in the request <code>requiredQuery</code> array every item in the array is a required query string parameter <code>availableQuery</code> array only items in this array are allowed in the request <code>requiredPath</code> string when using parameters, this is the required parameters <code>requiredBody</code> string references a JSschema component in your <code>schemaFile</code> <code>requiredResposne</code> string references a JSschema component in your <code>schemaFile</code> <code>requiredAuth</code> boolean will trigger <code>withAuth</code> function defined in the router config <code>before</code> function a custom function to be ran before your method function <code>after</code> function a custom function to be ran after your method function <code>dataClass</code> class a custom class that will be passed instead of the request obj <code>timeout</code> number a timeout value in microseconds to stop endpoint from running [<code>custom-requirement</code>] any see bottom of page"},{"location":"apigateway/endpoint/configurations/#requiredheaders","title":"<code>requiredHeaders</code>","text":"Info <p>Headers are case-sensitive, make sure your casing matches your expectations.</p> Functional PatternDecorator Pattern <pre><code>export const requirements = {\n    post: {\n        requiredHeaders: ['x-onbehalf-of']\n    }\n};\n</code></pre> <pre><code>import { BaseEndpoint, Validate, Request, Response } from 'acai-ts';\n\nexport class MyEndpoint extends BaseEndpoint {\n    @Validate({ requiredHeaders: ['x-onbehalf-of'] })\n    async post(request: Request, response: Response): Promise&lt;Response&gt; {\n        // Headers are validated automatically\n        response.body = { message: 'Headers validated' };\n        return response;\n    }\n}\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#availableheaders","title":"<code>availableHeaders</code>","text":"Warning <p>This is not recommended for frequent use as it raises errors for every header which does not conform to the array provided. Many browsers, http tools, and libraries will automatically add headers to request, unbeknownst to the user. By using this setting, you will force every user of the endpoint to take extra care with the headers provided and may result in poor API consumer experience.</p> Functional PatternDecorator Pattern <pre><code>export const requirements = {\n    post: {\n        availableHeaders: ['x-onbehalf-of']\n    }\n};\n</code></pre> <pre><code>import { BaseEndpoint, Validate, Request, Response } from 'acai-ts';\n\nexport class MyEndpoint extends BaseEndpoint {\n    @Validate({ \n        headers: {\n            type: 'object',\n            additionalProperties: false, // Only allow specified headers\n            properties: {\n                'x-onbehalf-of': { type: 'string' }\n            }\n        }\n    })\n    async post(request: Request, response: Response): Promise&lt;Response&gt; {\n        response.body = { message: 'Only specified headers allowed' };\n        return response;\n    }\n}\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#requiredquery","title":"<code>requiredQuery</code>","text":"Functional PatternDecorator Pattern <pre><code>export const requirements = {\n    get: {\n        requiredQuery: ['requester_id']\n    }\n};\n</code></pre> <pre><code>import { BaseEndpoint, Validate, Request, Response } from 'acai-ts';\n\nexport class MyEndpoint extends BaseEndpoint {\n    @Validate({ requiredQuery: ['requester_id'] })\n    async get(request: Request, response: Response): Promise&lt;Response&gt; {\n        const requesterId = request.queryParameters.requester_id;\n        response.body = { requesterId };\n        return response;\n    }\n}\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#availablequery","title":"<code>availableQuery</code>","text":"Functional PatternDecorator Pattern <pre><code>export const requirements = {\n    get: {\n        availableQuery: ['grower_email', 'grower_phone', 'grower_first', 'grower_last']\n    }\n};\n</code></pre> <pre><code>import { BaseEndpoint, Validate, Request, Response } from 'acai-ts';\n\nexport class MyEndpoint extends BaseEndpoint {\n    @Validate({ \n        query: {\n            type: 'object',\n            additionalProperties: false, // Only allow specified query params\n            properties: {\n                grower_email: { type: 'string' },\n                grower_phone: { type: 'string' },\n                grower_first: { type: 'string' },\n                grower_last: { type: 'string' }\n            }\n        }\n    })\n    async get(request: Request, response: Response): Promise&lt;Response&gt; {\n        response.body = { query: request.queryParameters };\n        return response;\n    }\n}\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#requiredpath","title":"<code>requiredPath</code>","text":"Warning <p>This is required if you are using dynamic routing (ex. <code>{id}.ts</code>) with path parameters. The router will provide path values in <code>request.pathParameters</code></p> Functional PatternDecorator Pattern <pre><code>export const requirements = {\n    put: {\n        requiredPath: 'grower/{id}'\n    }\n};\n</code></pre> <pre><code>import { BaseEndpoint, Validate, Request, Response } from 'acai-ts';\n\nexport class MyEndpoint extends BaseEndpoint {\n    @Validate({ \n        path: {\n            type: 'object',\n            required: ['id'],\n            properties: {\n                id: { type: 'string' }\n            }\n        }\n    })\n    async put(request: Request, response: Response): Promise&lt;Response&gt; {\n        const { id } = request.pathParameters;\n        response.body = { message: `Updated grower ${id}` };\n        return response;\n    }\n}\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#requiredbody","title":"<code>requiredBody</code>","text":"Info <p>This is referencing a <code>components.schemas</code> section of your openapi.yml file defined in the <code>schemaPath</code> value in your router config.</p> Functional PatternDecorator Pattern <pre><code>export const requirements = {\n    post: {\n        requiredBody: 'post-grower-request'\n    }\n};\n</code></pre> <pre><code>import { BaseEndpoint, Validate, Request, Response } from 'acai-ts';\n\nexport class MyEndpoint extends BaseEndpoint {\n    @Validate({ requiredBody: 'post-grower-request' })\n    async post(request: Request, response: Response): Promise&lt;Response&gt; {\n        // Body is validated against OpenAPI schema\n        const grower = request.body;\n        response.body = { message: 'Grower created', grower };\n        return response;\n    }\n}\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#requiredresponse","title":"<code>requiredResponse</code>","text":"Info <p>This is referencing a <code>components.schemas</code> section of your openapi.yml file defined in the <code>schemaPath</code> value in your router config.</p> Functional PatternDecorator Pattern <pre><code>export const requirements = {\n    post: {\n        requiredResponse: 'post-grower-response'\n    }\n};\n</code></pre> <pre><code>import { BaseEndpoint, Validate, Request, Response } from 'acai-ts';\n\nexport class MyEndpoint extends BaseEndpoint {\n    @Validate({ \n        requiredBody: 'post-grower-request',\n        response: {\n            type: 'object',\n            required: ['id', 'name'],\n            properties: {\n                id: { type: 'string' },\n                name: { type: 'string' }\n            }\n        }\n    })\n    async post(request: Request, response: Response): Promise&lt;Response&gt; {\n        // Response will be validated against schema\n        response.body = { id: '123', name: 'John Doe' };\n        return response;\n    }\n}\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#requiredauth","title":"<code>requiredAuth</code>","text":"Info <p>This will trigger the function you provided in the router config under the <code>withAuth</code> configuration</p> Functional PatternDecorator Pattern <pre><code>export const requirements = {\n    post: {\n        auth: true\n    }\n};\n</code></pre> <pre><code>import { BaseEndpoint, Auth, Request, Response } from 'acai-ts';\n\nexport class MyEndpoint extends BaseEndpoint {\n    @Auth()\n    async post(request: Request, response: Response): Promise&lt;Response&gt; {\n        // Authentication is handled by router's withAuth middleware\n        response.body = { message: 'Authenticated request' };\n        return response;\n    }\n}\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#before","title":"<code>before</code>","text":"Functional PatternDecorator Pattern <pre><code>import { Request, Response } from 'acai-ts';\nimport * as db from './logic/database';\n\nconst checkGrowerExists = async (request: Request, response: Response): Promise&lt;void&gt; =&gt; {\n    const result = await db.checkGrowerIdExists(request.pathParameters.id);\n    if (!result) {\n        response.code = 404;\n        response.setError('grower', `grower with id: ${request.pathParameters.id} does not exist.`);\n    }\n};\n\nexport const requirements = {\n    patch: {\n        before: [checkGrowerExists]\n    }\n};\n</code></pre> <pre><code>import { BaseEndpoint, Before, Request, Response } from 'acai-ts';\nimport * as db from './logic/database';\n\nconst checkGrowerExists = async (request: Request, response: Response): Promise&lt;void&gt; =&gt; {\n    const result = await db.checkGrowerIdExists(request.pathParameters.id);\n    if (!result) {\n        response.code = 404;\n        response.setError('grower', `grower with id: ${request.pathParameters.id} does not exist.`);\n    }\n};\n\nexport class MyEndpoint extends BaseEndpoint {\n    @Before(checkGrowerExists)\n    async patch(request: Request, response: Response): Promise&lt;Response&gt; {\n        // Pre-validation middleware runs first\n        response.body = { message: 'Grower exists and updated' };\n        return response;\n    }\n}\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#after","title":"<code>after</code>","text":"Functional PatternDecorator Pattern <pre><code>import { Request, Response } from 'acai-ts';\nimport * as db from './logic/database';\n\nconst filterByRelations = async (request: Request, response: Response): Promise&lt;void&gt; =&gt; {\n    const relations = await db.getRequesterRelations(request.headers['x-requester-id']);\n    const results: any[] = [];\n    for (const grower of response.body) {\n        if (relations.includes(grower.id)) {\n            results.push(grower);\n        }\n    }\n    response.body = results;\n};\n\nexport const requirements = {\n    get: {\n        after: [filterByRelations]\n    }\n};\n</code></pre> <pre><code>import { BaseEndpoint, After, Request, Response } from 'acai-ts';\nimport * as db from './logic/database';\n\nconst filterByRelations = async (request: Request, response: Response): Promise&lt;void&gt; =&gt; {\n    const relations = await db.getRequesterRelations(request.headers['x-requester-id']);\n    const results: any[] = [];\n    for (const grower of response.body) {\n        if (relations.includes(grower.id)) {\n            results.push(grower);\n        }\n    }\n    response.body = results;\n};\n\nexport class MyEndpoint extends BaseEndpoint {\n    @After(filterByRelations)\n    async get(request: Request, response: Response): Promise&lt;Response&gt; {\n        response.body = [{ id: '1', name: 'Grower 1' }, { id: '2', name: 'Grower 2' }];\n        // Post-processing middleware will filter results\n        return response;\n    }\n}\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#dataclass","title":"<code>dataClass</code>","text":"Info <p>Instead of getting a <code>request</code> and <code>response</code> as arguments passed to your API function, you will get an instance of the class you provided here (functional pattern only)</p> Functional PatternDecorator Pattern <pre><code>import { Grower } from './logic/grower';\n\nexport const requirements = {\n    post: {\n        dataClass: Grower\n    }\n};\n\n// Handler receives Grower instance instead of request\nexport const post = async (grower: Grower, response: Response): Promise&lt;Response&gt; =&gt; {\n    response.body = { message: 'Received grower instance', grower };\n    return response;\n};\n</code></pre> <pre><code>// Note: dataClass is not supported with decorator pattern\n// Instead, use validation and manual class instantiation\nimport { BaseEndpoint, Validate, Request, Response } from 'acai-ts';\nimport { Grower } from './logic/grower';\n\nexport class MyEndpoint extends BaseEndpoint {\n    @Validate({ requiredBody: 'GrowerSchema' })\n    async post(request: Request, response: Response): Promise&lt;Response&gt; {\n        const grower = new Grower(request.body);\n        response.body = { message: 'Grower created', grower };\n        return response;\n    }\n}\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#timeout","title":"<code>timeout</code>","text":"Info <p>This value will OVERRIDE any value set in the global timeout settings, set in the router config</p> Functional PatternDecorator Pattern <pre><code>export const requirements = {\n    post: {\n        timeout: 20000 // overrides other timeouts set in router config\n    }\n};\n</code></pre> <pre><code>import { BaseEndpoint, Timeout, Request, Response } from 'acai-ts';\n\nexport class MyEndpoint extends BaseEndpoint {\n    @Timeout(20000) // 20 seconds - overrides router config\n    async post(request: Request, response: Response): Promise&lt;Response&gt; {\n        // Long-running operation with custom timeout\n        await someLongRunningOperation();\n        response.body = { message: 'Long operation completed' };\n        return response;\n    }\n}\n</code></pre>"},{"location":"apigateway/endpoint/configurations/#custom-requirements-example","title":"custom requirements (example)","text":"Info <p>You can add as many custom requirements as you want, with any variable type you want, and they will be passed to your <code>beforeAll</code>, <code>before</code>, <code>afterAll</code>, <code>after</code> and <code>withAuth</code> middleware defined functions.</p> Functional PatternDecorator Pattern <pre><code>interface CustomPermission {\n    permission: string;\n}\n\nexport const requirements = {\n    post: {\n        myCustomBeforeAllPermission: { permission: 'allow-delete-grower' } as CustomPermission\n    }\n};\n</code></pre> <pre><code>import { BaseEndpoint, Before, Request, Response } from 'acai-ts';\n\ninterface CustomPermission {\n    permission: string;\n}\n\nconst checkCustomPermission = async (request: Request, response: Response): Promise&lt;void&gt; =&gt; {\n    const permission = 'allow-delete-grower'; // Custom logic here\n    if (!hasPermission(request, permission)) {\n        response.code = 403;\n        response.setError('permission', 'Insufficient permissions');\n    }\n};\n\nexport class MyEndpoint extends BaseEndpoint {\n    @Before(checkCustomPermission)\n    async post(request: Request, response: Response): Promise&lt;Response&gt; {\n        // Custom permission validation handled by middleware\n        response.body = { message: 'Custom permission validated' };\n        return response;\n    }\n}\n</code></pre>"},{"location":"apigateway/endpoint/setup/","title":"Endpoint Set Up","text":"<p>Acai-TS supports two patterns for defining endpoints: functional pattern (using exported functions with requirements) and decorator pattern (using classes with method decorators). Both approaches follow the \"Happy Path Programming\" philosophy where validation happens upfront, ensuring your business logic runs cleanly without defensive coding.</p> Choose Your Pattern <ul> <li>Functional Pattern: Best for explicit configuration objects and JavaScript/TypeScript mixed codebases</li> <li>Decorator Pattern: Best for TypeScript-first development with declarative annotations</li> </ul> Examples <p>Don't like reading documentation? Then look at our examples, which can run locally!</p>"},{"location":"apigateway/endpoint/setup/#functional-pattern","title":"Functional Pattern","text":""},{"location":"apigateway/endpoint/setup/#1-match-function-to-http-method","title":"1. Match Function to HTTP Method","text":"<p>Each endpoint file exports functions matching HTTP method names. When an endpoint receives a <code>POST</code> request, the <code>post</code> function is invoked.</p> <pre><code>// File: src/handlers/grower.ts\nimport { Request, Response } from 'acai-ts';\n\nexport const requirements = {}; // discussed in next section below\n\nexport const post = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n    response.body = { message: '[POST] /grower was called' };\n    return response;\n};\n\nexport const get = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n    response.body = { message: '[GET] /grower was called' };\n    return response;\n};\n\nexport const patch = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n    response.body = { message: '[PATCH] /grower was called' };\n    return response;\n};\n\nexport const put = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n    response.body = { message: '[PUT] /grower was called' };\n    return response;\n};\n\nexport const delete = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n    response.body = { message: '[DELETE] /grower was called' };\n    return response;\n};\n\nexport const query = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n    response.body = { message: '[QUERY] /grower, a custom http method, was called' };\n    return response;\n};\n</code></pre>"},{"location":"apigateway/endpoint/setup/#2-configure-the-requirements-optional","title":"2. Configure the Requirements (optional)","text":"<p>Each method within the endpoint file can have individual validation requirements. These requirements allow you to test all structural points of the request, with the ability to use JSONSchema and custom middleware to further extend the validation options. Below is an example of a full requirements object:</p> Info <p>See the full configuration list, explanation and example of each setting in our Configurations Section.</p> Tip <p>If you are already using an <code>openapi.yml</code>, none of these requirements below are necessary. Ensure your <code>router</code> has enabled <code>autoValidate</code> with proper <code>schemaPath</code> configured and the below requirements are not necessary for any basic structural validation (headers, body, query, params will be checked via openapi.yml). You can still use <code>before</code>, <code>after</code> &amp; <code>dataClass</code> with other custom validations for more advanced use cases.</p> <pre><code>// File: src/handlers/grower.ts\nimport { Request, Response } from 'acai-ts';\nimport { Grower } from './logic/grower';\nimport * as db from './logic/database';\n\n// Middleware functions\nconst checkGrowerExists = async (request: Request, response: Response): Promise&lt;void&gt; =&gt; {\n    const result = await db.checkGrowerIdExists(request.pathParameters.id);\n    if (!result) {\n        response.code = 404;\n        response.setError('grower', `grower with id: ${request.pathParameters.id} does not exist.`);\n    }\n};\n\nconst filterByRelations = async (request: Request, response: Response): Promise&lt;void&gt; =&gt; {\n    const relations = await db.getRequesterRelations(request.headers['x-requester-id']);\n    const results: any[] = [];\n    for (const grower of response.body) {\n        if (relations.includes(grower.id)) {\n            results.push(grower);\n        }\n    }\n    response.body = results;\n};\n\nexport const requirements = {\n    post: {\n        requiredHeaders: ['x-onbehalf-of'],\n        requiredBody: 'post-grower-request'\n    },\n    get: {\n        requiredQuery: ['requester_id']\n    },\n    put: {\n        auth: true,\n        requiredBody: 'put-grower-request',\n        timeout: 1500 // will override timeout value set in router config\n    },\n    patch: {\n        auth: true,\n        requiredBody: 'patch-grower-request',\n        before: [checkGrowerExists]\n    },\n    delete: {\n        after: [filterByRelations]\n    }\n};\n\nexport const post = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n    response.body = { message: '[POST] /grower was called' };\n    return response;\n};\n\nexport const get = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n    response.body = { message: '[GET] /grower was called' };\n    return response;\n};\n\nexport const patch = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n    response.body = { message: '[PATCH] /grower was called' };\n    return response;\n};\n\nexport const put = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n    response.body = { message: '[PUT] /grower was called' };\n    return response;\n};\n\nexport const delete = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n    response.body = { message: '[DELETE] /grower was called' };\n    return response;\n};\n\nexport const query = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n    response.body = { message: '[QUERY] /grower, a custom http method, was called' };\n    return response;\n};\n</code></pre>"},{"location":"apigateway/endpoint/setup/#decorator-pattern","title":"Decorator Pattern","text":""},{"location":"apigateway/endpoint/setup/#1-create-class-extending-baseendpoint","title":"1. Create Class Extending BaseEndpoint","text":"<p>The decorator pattern uses classes that extend <code>BaseEndpoint</code> with method decorators for configuration.</p> <pre><code>// File: src/handlers/grower.ts\nimport 'reflect-metadata';\nimport { BaseEndpoint, Request, Response } from 'acai-ts';\n\nexport class GrowerEndpoint extends BaseEndpoint {\n    async post(request: Request, response: Response): Promise&lt;Response&gt; {\n        response.body = { message: '[POST] /grower was called' };\n        return response;\n    }\n\n    async get(request: Request, response: Response): Promise&lt;Response&gt; {\n        response.body = { message: '[GET] /grower was called' };\n        return response;\n    }\n\n    async patch(request: Request, response: Response): Promise&lt;Response&gt; {\n        response.body = { message: '[PATCH] /grower was called' };\n        return response;\n    }\n\n    async put(request: Request, response: Response): Promise&lt;Response&gt; {\n        response.body = { message: '[PUT] /grower was called' };\n        return response;\n    }\n\n    async delete(request: Request, response: Response): Promise&lt;Response&gt; {\n        response.body = { message: '[DELETE] /grower was called' };\n        return response;\n    }\n\n    async query(request: Request, response: Response): Promise&lt;Response&gt; {\n        response.body = { message: '[QUERY] /grower, a custom http method, was called' };\n        return response;\n    }\n}\n</code></pre>"},{"location":"apigateway/endpoint/setup/#2-add-method-decorators-optional","title":"2. Add Method Decorators (optional)","text":"<p>Use decorators to configure validation, authentication, middleware, and timeouts for each HTTP method.</p> <pre><code>// File: src/handlers/grower.ts\nimport 'reflect-metadata';\nimport { BaseEndpoint, Validate, Auth, Before, After, Timeout, Request, Response } from 'acai-ts';\nimport { Grower } from './logic/grower';\nimport * as db from './logic/database';\n\n// Middleware functions\nconst checkGrowerExists = async (request: Request, response: Response): Promise&lt;void&gt; =&gt; {\n    const result = await db.checkGrowerIdExists(request.pathParameters.id);\n    if (!result) {\n        response.code = 404;\n        response.setError('grower', `grower with id: ${request.pathParameters.id} does not exist.`);\n    }\n};\n\nconst filterByRelations = async (request: Request, response: Response): Promise&lt;void&gt; =&gt; {\n    const relations = await db.getRequesterRelations(request.headers['x-requester-id']);\n    const results: any[] = [];\n    for (const grower of response.body) {\n        if (relations.includes(grower.id)) {\n            results.push(grower);\n        }\n    }\n    response.body = results;\n};\n\nconst logRequest = async (request: Request, response: Response): Promise&lt;void&gt; =&gt; {\n    console.log(`${request.method} ${request.path} - ${new Date().toISOString()}`);\n};\n\nexport class GrowerEndpoint extends BaseEndpoint {\n    @Validate({ requiredHeaders: ['x-onbehalf-of'], requiredBody: 'post-grower-request' })\n    @Before(logRequest)\n    async post(request: Request, response: Response): Promise&lt;Response&gt; {\n        response.body = { message: '[POST] /grower was called' };\n        return response;\n    }\n\n    @Validate({ requiredQuery: ['requester_id'] })\n    @Before(logRequest)\n    async get(request: Request, response: Response): Promise&lt;Response&gt; {\n        response.body = { message: '[GET] /grower was called' };\n        return response;\n    }\n\n    @Auth()\n    @Validate({ requiredBody: 'patch-grower-request' })\n    @Before(checkGrowerExists)\n    @Before(logRequest)\n    async patch(request: Request, response: Response): Promise&lt;Response&gt; {\n        response.body = { message: '[PATCH] /grower was called' };\n        return response;\n    }\n\n    @Auth()\n    @Validate({ requiredBody: 'put-grower-request' })\n    @Before(logRequest)\n    @Timeout(1500)\n    async put(request: Request, response: Response): Promise&lt;Response&gt; {\n        response.body = { message: '[PUT] /grower was called' };\n        return response;\n    }\n\n    @Before(logRequest)\n    @After(filterByRelations)\n    async delete(request: Request, response: Response): Promise&lt;Response&gt; {\n        response.body = { message: '[DELETE] /grower was called' };\n        return response;\n    }\n\n    async query(request: Request, response: Response): Promise&lt;Response&gt; {\n        response.body = { message: '[QUERY] /grower, a custom http method, was called' };\n        return response;\n    }\n}\n</code></pre>"},{"location":"apigateway/endpoint/setup/#available-decorators","title":"Available Decorators","text":"Decorator Purpose Example <code>@Validate()</code> Request validation <code>@Validate({ requiredBody: 'UserSchema' })</code> <code>@Auth()</code> Authentication required <code>@Auth()</code> or <code>@Auth(false)</code> <code>@Before()</code> Pre-processing middleware <code>@Before(authMiddleware, loggingMiddleware)</code> <code>@After()</code> Post-processing middleware <code>@After(loggingMiddleware)</code> <code>@Timeout()</code> Method timeout <code>@Timeout(5000)</code>"},{"location":"apigateway/endpoint/setup/#decorator-execution-order","title":"Decorator Execution Order","text":"<ol> <li><code>@Before</code> middleware (runs first)</li> <li><code>@Auth</code> authentication (router's <code>withAuth</code> middleware)</li> <li><code>@Validate</code> validation</li> <li>HTTP method with <code>@Timeout</code></li> <li><code>@After</code> middleware (runs last)</li> </ol>"},{"location":"apigateway/endpoint/setup/#pattern-comparison","title":"Pattern Comparison","text":"Feature Functional Pattern Decorator Pattern Configuration <code>requirements</code> object Method decorators TypeScript Required No Yes File Structure Export functions Export class Middleware Arrays in requirements Multiple decorators Reusability High (shared requirements) Moderate Co-location Separate from methods Inline with methods"},{"location":"apigateway/router/configurations/","title":"Router Configurations","text":"<p>As mentioned previously, the router is highly configurable to each project needs and desires. The point of the router is to enforce predictable thus making the API more extensible. Below is a table of all the configuration options available:</p> Example <p>Don't like reading documentation? Then look at our examples which can run locally!</p>"},{"location":"apigateway/router/configurations/#configuration-options","title":"Configuration Options","text":"option type required description <code>routesPath</code> string yes glob pattern to match handler files (supports TypeScript paths with auto-transform) <code>basePath</code> string no the base path to strip from requests (e.g., '/api/v1') <code>schemaPath</code> string no; required if using <code>autoValidate</code> file path pointing to the location of the openapi.yml file <code>buildOutputDir</code> string no build output directory for TypeScript compilation (auto-detects if not specified) <code>cache</code> enum no; 'all', 'dynamic', 'static', 'none' cache mode for route resolution (default: optimized caching) <code>autoValidate</code> boolean no; requires <code>schemaPath</code> automatically validate requests against OpenAPI schema <code>validateResponse</code> boolean no validate responses against schema (useful for development) <code>timeout</code> number no global timeout in milliseconds for all endpoints <code>outputError</code> boolean no, (default: false) output detailed error messages (recommended for non-production) <code>globalLogger</code> boolean no enable global logger accessible via <code>global.logger</code> <code>loggerCallback</code> function no custom callback function for all log messages <code>beforeAll</code> function no middleware to run before EVERY request <code>afterAll</code> function no middleware to run after EVERY request <code>withAuth</code> function no global authentication middleware (triggered by <code>@Auth()</code> or <code>auth: true</code>) <code>onError</code> function no error handler for unhandled errors (not validation errors) <code>onTimeout</code> function no timeout handler when requests exceed timeout setting"},{"location":"apigateway/router/configurations/#example-router-configuration","title":"Example: Router Configuration","text":"<pre><code>import 'reflect-metadata';\nimport { Router } from 'acai-ts';\nimport { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\nimport { MiddlewareUtils } from './logic/middleware';\nimport { Authenticator } from './logic/authenticator';\n\nconst router = new Router({\n    basePath: '/api/v1',\n    routesPath: './src/handlers/**/*.ts',    // File-based routing with auto-transform\n    schemaPath: './openapi.yml',\n    buildOutputDir: '.build',               // Optional: auto-detects if not specified\n    cache: 'all',                          // Cache all routes for performance\n    autoValidate: true,\n    validateResponse: process.env.STAGE !== 'prod', // Validate responses in dev\n    timeout: 30000,                        // 30 seconds in milliseconds\n    outputError: process.env.STAGE !== 'prod',      // Show errors in dev\n    globalLogger: true,\n    loggerCallback: MiddlewareUtils.loggerCallback,\n    beforeAll: MiddlewareUtils.beforeAll,\n    afterAll: MiddlewareUtils.afterAll,\n    withAuth: Authenticator.authenticate,   // Global auth middleware\n    onError: MiddlewareUtils.onError,\n    onTimeout: MiddlewareUtils.onTimeout\n});\n\n// Optional: pre-load routes and schema for better cold start performance\nrouter.autoLoad();\n\nexport const handler = async (\n    event: APIGatewayProxyEvent\n): Promise&lt;APIGatewayProxyResult&gt; =&gt; {\n    return await router.route(event);\n};\n</code></pre>"},{"location":"apigateway/router/configurations/#example-router-config-with-minimal-setup","title":"Example: Router Config with Minimal Setup","text":"<pre><code>import 'reflect-metadata';\nimport { Router } from 'acai-ts';\nimport { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\n\n// Minimal configuration - most options are optional and have sensible defaults\nconst router = new Router({\n    routesPath: './src/handlers/**/*.ts'  // Only required option\n});\n\nexport const handler = async (\n    event: APIGatewayProxyEvent\n): Promise&lt;APIGatewayProxyResult&gt; =&gt; {\n    return await router.route(event);\n};\n</code></pre>"},{"location":"apigateway/router/configurations/#example-advanced-router-configuration","title":"Example: Advanced Router Configuration","text":"<pre><code>import 'reflect-metadata';\nimport { Router } from 'acai-ts';\nimport { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\n\n// Custom middleware functions\nconst authMiddleware = async (request, response) =&gt; {\n    const token = request.headers.authorization?.replace('Bearer ', '');\n    if (!token || !validateJWT(token)) {\n        response.code = 401;\n        response.setError('auth', 'Unauthorized');\n    }\n};\n\nconst loggerCallback = (log) =&gt; {\n    // Send to external logging service\n    console.log(JSON.stringify(log));\n};\n\nconst router = new Router({\n    // Required\n    routesPath: './src/handlers/**/*.ts',\n\n    // Optional configurations\n    basePath: '/api/v1',\n    schemaPath: './openapi.yml',\n    buildOutputDir: '.build',\n    cache: 'all',\n    autoValidate: true,\n    validateResponse: process.env.NODE_ENV === 'development',\n    timeout: 30000,\n    outputError: process.env.NODE_ENV !== 'production',\n    globalLogger: true,\n    loggerCallback,\n\n    // Middleware\n    beforeAll: async (request, response) =&gt; {\n        console.log(`${request.method} ${request.path}`);\n    },\n    afterAll: async (request, response) =&gt; {\n        console.log(`Response: ${response.code}`);\n    },\n    withAuth: authMiddleware,\n    onError: async (request, response, error) =&gt; {\n        console.error('Unhandled error:', error.message);\n    },\n    onTimeout: async (request, response, error) =&gt; {\n        console.warn('Request timeout:', request.path);\n    }\n});\n\nrouter.autoLoad();\n\nexport const handler = async (\n    event: APIGatewayProxyEvent\n): Promise&lt;APIGatewayProxyResult&gt; =&gt; {\n    return await router.route(event);\n};\n</code></pre>"},{"location":"apigateway/router/configurations/#route-path-patterns","title":"Route Path Patterns","text":"<p>The <code>routesPath</code> option supports flexible glob patterns for organizing your handlers:</p> <pre><code>// Standard structure\nroutesPath: './src/handlers/**/*.ts'\n\n// Controller pattern\nroutesPath: './src/api/**/*.controller.ts'\n\n// Specific directories\nroutesPath: './src/endpoints/**/*.ts'\n\n// Multiple patterns (if your build tool supports it)\nroutesPath: './src/{handlers,endpoints}/**/*.ts'\n</code></pre>"},{"location":"apigateway/router/configurations/#file-structure-examples","title":"File Structure Examples","text":"<pre><code># Standard Structure\nsrc/handlers/\n\u251c\u2500\u2500 users.ts              \u2192 /users\n\u251c\u2500\u2500 users/{id}.ts         \u2192 /users/{id}\n\u2514\u2500\u2500 products/\n    \u251c\u2500\u2500 index.ts          \u2192 /products\n    \u2514\u2500\u2500 {id}/reviews.ts   \u2192 /products/{id}/reviews\n\n# Controller Pattern\nsrc/api/\n\u251c\u2500\u2500 users.controller.ts      \u2192 /users  \n\u251c\u2500\u2500 user-detail.controller.ts \u2192 /user-detail\n\u2514\u2500\u2500 products/\n    \u2514\u2500\u2500 product.controller.ts \u2192 /products/product\n</code></pre>"},{"location":"apigateway/router/setup/","title":"Router Set Up","text":"Example <p>Don't like reading documentation? Then look at our examples which can run locally!</p>"},{"location":"apigateway/router/setup/#1-configure-the-lambda","title":"1. Configure the Lambda","text":"Serverless Framework <pre><code>functions:\n    apigateway-handler:\n        handler: api/handler/router.route\n        events:\n            - http:\n                path: /\n                method: ANY\n            - http:\n                path: /{proxy+}\n                method: ANY\n</code></pre>"},{"location":"apigateway/router/setup/#2-configure-the-router","title":"2. Configure the Router","text":"<p>There are three routing modes: <code>directory</code>, <code>pattern</code> and <code>list</code>; <code>directory</code> and <code>pattern</code> routing mode requires your project files to be placed in a particular way; <code>list</code> does not require any structure, as you define every route and it's corresponding file. Below are the three ways configure your router:</p>"},{"location":"apigateway/router/setup/#routing-mode-directory","title":"Routing Mode: Directory","text":"Tip <p>If you are using route params, you will need use dynamic file names which follow this pattern: <code>{some-variable-name}.ts</code>.</p> file structurerouter.ts <pre><code>~~ Directory ~~                     ~~ Route ~~\n===================================================================\n=api/                              |\n---=handler                       |\n    ---=router.ts                 |\n    ---=org.ts                    | /org\n    ---=grower                    |\n        ---=index.ts              | /grower\n        ---={growerId}.ts         | /grower/{growerId}\n    ---=farm                      |\n        ---=index.ts              | /farm\n        ---={farmId}              |\n            ---=index.ts          | /farm/{farmId}\n            ---=field             |\n                ---=index.ts      | /farm/{farmId}/field\n                ---={fieldId}.ts  | /farm/{farmId}/field/{fieldId}\n</code></pre> <pre><code>import { Router } from 'acai-ts';\nimport { APIGatewayProxyEventV2 } from 'aws-lambda';\n\nconst router = new Router({\n    mode: 'directory',\n    basePath: 'api', // for use with custom apigateway domain\n    routesPath: 'api/handler'\n});\nrouter.autoLoad() // optional; pulls in files from disc into memory and shares on with concurrent lambdas\n\nexport const route = async (event: APIGatewayProxyEventV2) =&gt; {\n    return router.route(event);\n};\n</code></pre>"},{"location":"apigateway/router/setup/#routing-mode-pattern","title":"Routing Mode: Pattern","text":"Tip <p>You can use any glob pattern you like; common patterns are:</p> <ul> <li> <p><code>/**/*.controller.ts</code></p> </li> <li> <p><code>/**/handler.*.ts</code></p> </li> <li> <p><code>/**/endpoint.ts</code></p> </li> </ul> file structurerouter.ts <pre><code>~~ Pattern ~~                               ~~ Route ~~\n================================================================================\n=api/                                      |\n---=router.ts                             |\n---=org                                   |\n    ---=org.controller.ts                 | /org\n    ---=org.model.ts                      |\n    ---=org.factory.ts                    |\n    ---=org.logic.ts                      |\n---=grower                                |\n    ---=grower.controller.ts              | /grower\n    ---={growerId}.controller.ts          | /grower/{growerId}\n    ---=grower.model.ts                   |\n    ---=grower.factory.ts                 |\n    ---=grower.logic.ts                   |\n---=farm                                  |\n    ---=farm.controller.ts                | /farm\n    ---=farm.logic.ts                     |\n    ---=farm.model.ts                     |\n    ---={farmId}                          |\n        ---={farmId}.controller.ts        | /farm/{farmId}\n        ---=field                         |\n            ---=field.controller.ts       | /farm/{farmId}/field\n            ---={fieldId}.controller.ts   | /farm/{farmId}/field/{fieldId}\n            ---=field.logic.ts            |\n            ---=field.model.ts            |\n</code></pre> <pre><code>import { Router } from 'acai-ts';\nimport { APIGatewayProxyEventV2 } from 'aws-lambda';\n\nexport const route = async (event: APIGatewayProxyEventV2) =&gt; {\n    const router = new Router({\n        mode: 'pattern',\n        basePath: 'api', // for use with custom apigateway domain\n        routesPath: 'api/**/*.controller.ts'\n    });\n    return router.route(event);\n};\n</code></pre>"},{"location":"apigateway/router/setup/#routing-mode-list","title":"Routing Mode: List","text":"Tip <p>It may be more maintainable to store your routes list in a separate file, this example does not have that for brevity</p> Warning <p>Even though you are matching your files to your routes, the handler files must have functions that match HTTP method (see endpoint examples here)</p> Danger <p>This is not the preferred routing mode to use; this can lead to a sloppy, unpredictable project architecture which will be hard to maintain and extend. This is NOT RECOMMENDED.</p> file structurerouter.ts <pre><code>File structure doesn't matter\n======================================================\n=api/\n---=router.ts\n</code></pre> <pre><code>import { Router } from 'acai-ts';\nimport { APIGatewayProxyEventV2 } from 'aws-lambda';\n\nconst router = new Router({\n    mode: 'list',\n    basePath: 'api', // for use with custom apigateway domain\n    routes: [\n        { method: 'GET', path: '/grower', handler: 'api/routes/grower.ts' },\n        { method: 'POST', path: '/farm', handler: 'api/routes/farm.ts' },\n        { method: 'PUT', path: '/farm/{farmId}/field/{fieldId}', handler: 'api/routes/farm-field.ts' }\n    ]\n});\n\nrouter.autoLoad() // optional; pulls in files from disc into memory and shares on with concurrent lambdas\n\nexport const route = async (event: APIGatewayProxyEventV2) =&gt; {\n    return router.route(event);\n};\n</code></pre>"},{"location":"apigateway/router/setup/#routing-mode-file-based-with-decorators","title":"Routing Mode: File-Based with Decorators","text":"Tip <p>This is the modern TypeScript approach using class-based endpoints with decorators. Perfect for type-safe development with clean, declarative configuration.</p> file structurerouter.tsusers.ts (endpoint) <pre><code>~~ File Structure ~~                    ~~ Route ~~\n===================================================================\n=src/\n\u251c\u2500\u2500handlers/\n\u2502   \u251c\u2500\u2500router.ts                        |\n\u2502   \u251c\u2500\u2500users.ts                         | /users (GET, POST, PUT, DELETE)\n\u2502   \u251c\u2500\u2500users/{id}.ts                    | /users/{id} (GET, PUT, DELETE)\n\u2502   \u251c\u2500\u2500products/\n\u2502   \u2502   \u251c\u2500\u2500index.ts                     | /products\n\u2502   \u2502   \u2514\u2500\u2500{id}/reviews.ts              | /products/{id}/reviews\n\u2502   \u2514\u2500\u2500health.ts                        | /health\n</code></pre> <pre><code>import 'reflect-metadata';\nimport { Router } from 'acai-ts';\nimport { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\n\nexport const handler = async (\n  event: APIGatewayProxyEvent\n): Promise&lt;APIGatewayProxyResult&gt; =&gt; {\n  const router = new Router({\n    basePath: '/api/v1',\n    routesPath: './src/handlers/**/*.ts',\n    schemaPath: './openapi.yml',\n    withAuth: async (request, response) =&gt; {\n      // Global auth middleware\n      const token = request.headers.authorization?.replace('Bearer ', '');\n      if (!token || !validateJWT(token)) {\n        response.code = 401;\n        response.setError('auth', 'Invalid token');\n      }\n    }\n  });\n\n  return await router.route(event);\n};\n</code></pre> <pre><code>import 'reflect-metadata';\nimport { BaseEndpoint, Validate, Auth, Before, After, Timeout, Request, Response } from 'acai-ts';\n\nconst logRequest = async (request: Request, response: Response) =&gt; {\n  console.log(`${request.method} ${request.path}`);\n};\n\nconst addTimestamp = async (request: Request, response: Response) =&gt; {\n  if (typeof response.body === 'object') {\n    response.body.timestamp = new Date().toISOString();\n  }\n};\n\nexport class UsersEndpoint extends BaseEndpoint {\n  @Before(logRequest)\n  @After(addTimestamp)\n  async get(request: Request, response: Response): Promise&lt;Response&gt; {\n    response.body = { users: [] };\n    return response;\n  }\n\n  @Auth()\n  @Validate({ requiredBody: 'CreateUserRequest' })\n  @Before(logRequest)\n  @After(addTimestamp)\n  @Timeout(5000)\n  async post(request: Request, response: Response): Promise&lt;Response&gt; {\n    const user = await createUser(request.body);\n    response.code = 201;\n    response.body = user;\n    return response;\n  }\n\n  @Auth()\n  @Validate({ requiredBody: 'UpdateUserRequest' })\n  async put(request: Request, response: Response): Promise&lt;Response&gt; {\n    const user = await updateUser(request.body);\n    response.body = user;\n    return response;\n  }\n\n  @Auth()\n  async delete(request: Request, response: Response): Promise&lt;Response&gt; {\n    await deleteUser(request.pathParameters.id);\n    response.code = 204;\n    return response;\n  }\n}\n</code></pre>"},{"location":"apigateway/router/setup/#3-configure-the-endpoint-file","title":"3. Configure the Endpoint File","text":"<p>Every endpoint file should contain a function which matches an HTTP method in lower case. Most common are <code>post</code>, <code>get</code>, <code>put</code>, <code>patch</code>, <code>delete</code>, but this library does support custom methods, if you so choose. As long as the method of the request matches the function name, it will work.</p> <p>Functional Pattern (requirements object): <pre><code>import { Request, Response } from 'acai-ts';\n\nexport const requirements = {\n    post: {\n        requiredBody: 'CreateItemRequest'\n    },\n    get: {\n        requiredHeaders: ['authorization']\n    }\n};\n\nexport const post = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n    response.body = { post: true };\n    return response;\n};\n\nexport const get = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n    response.body = { get: true };\n    return response;\n};\n\nexport const patch = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n    response.body = { patch: true };\n    return response;\n};\n\nexport const put = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n    response.body = { put: true };\n    return response;\n};\n\nexport const delete = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n    response.body = { delete: true };\n    return response;\n};\n\n// this is a non-compliant, custom http method; this will work.\nexport const query = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n    response.body = [{ query: true }];\n    return response;\n};\n</code></pre></p> <p>Decorator Pattern (class-based): <pre><code>import { BaseEndpoint, Validate, Auth, Request, Response } from 'acai-ts';\n\nexport class ItemEndpoint extends BaseEndpoint {\n    @Validate({ requiredBody: 'CreateItemRequest' })\n    async post(request: Request, response: Response): Promise&lt;Response&gt; {\n        response.body = { post: true };\n        return response;\n    }\n\n    @Auth()\n    async get(request: Request, response: Response): Promise&lt;Response&gt; {\n        response.body = { get: true };\n        return response;\n    }\n\n    async patch(request: Request, response: Response): Promise&lt;Response&gt; {\n        response.body = { patch: true };\n        return response;\n    }\n\n    async put(request: Request, response: Response): Promise&lt;Response&gt; {\n        response.body = { put: true };\n        return response;\n    }\n\n    async delete(request: Request, response: Response): Promise&lt;Response&gt; {\n        response.body = { delete: true };\n        return response;\n    }\n\n    // this is a non-compliant, custom http method; this will work.\n    async query(request: Request, response: Response): Promise&lt;Response&gt; {\n        response.body = [{ query: true }];\n        return response;\n    }\n}\n</code></pre></p>"},{"location":"common/logger/","title":"Logger","text":"<p>The Acai-TS logger automatically logs in a formatted JSON string for easy reading and searching with AWS CloudWatch. A developer can then use AWS filter patterns making it effortless to find the exact log they are looking for. Below is an example of how to use the logger:</p>"},{"location":"common/logger/#examples","title":"\ud83d\udcda Examples","text":""},{"location":"common/logger/#basic-usage","title":"\ud83d\ude80 Basic Usage","text":"<pre><code>import { Logger } from 'acai-ts';\n\n// If you use globalLogger: true in any config, the logger is available globally\nLogger.info('testing info');\n\nLogger.debug('testing debug');\n\nLogger.warn('testing warn');\n\nLogger.error('testing error');\n\n// Standard output\n{\n    level: '$LEVEL', \n    log: '$MESSAGE'\n}\n</code></pre>"},{"location":"common/logger/#advanced-usage","title":"\ud83d\udd27 Advanced Usage","text":"<pre><code>import { Logger } from 'acai-ts';\n\n// Custom log object with structured data\nLogger.log({ level: 'INFO', log: { someKey: 'testing info' } });\n\n// Standard output\n{\n    level: 'INFO',\n    log: {\n        someKey: 'testing info'\n    }\n}\n</code></pre>"},{"location":"common/logger/#global-logger-setup","title":"\ud83c\udf0d Global Logger Setup","text":"<pre><code>import { Logger } from 'acai-ts';\n\n// Set up global logger with custom callback\nLogger.setUpGlobal(true, {\n  callback: (level: string, ...args: any[]) =&gt; {\n    // Custom logging logic (e.g., send to CloudWatch, Datadog, etc.)\n    console.log(`[${level}]`, ...args);\n  }\n});\n\n// Now logger is available throughout your application\nLogger.info('Application started');\n</code></pre>"},{"location":"common/logger/#typescript-types","title":"\ud83d\udcdd TypeScript Types","text":"<pre><code>import { Logger } from 'acai-ts';\n\n// Logger methods are fully typed\nLogger.info('string message');                    // \u2705 Valid\nLogger.log({ level: 'INFO', log: 'message' });   // \u2705 Valid\nLogger.error('error', new Error('Something'));    // \u2705 Valid\n\n// Type-safe log levels\ntype LogLevel = 'DEBUG' | 'INFO' | 'WARN' | 'ERROR';\n\nconst level: LogLevel = 'INFO';\nLogger.log({ level, log: { data: 'value' } });\n</code></pre>"},{"location":"common/logger/#configuration-options","title":"\u2699\ufe0f Configuration Options","text":"<p>The logger can be configured when setting up your Event handlers or Router:</p> <pre><code>import { Event } from 'acai-ts';\nimport { DynamoDBStreamEvent } from 'aws-lambda';\n\nexport const handler = async (event: DynamoDBStreamEvent): Promise&lt;void&gt; =&gt; {\n  const dynamodb = new Event(event, {\n    globalLogger: true,  // Enable global logger\n    operations: ['INSERT', 'MODIFY']\n  });\n\n  // Logger is now available\n  Logger.info('Processing DynamoDB stream');\n\n  await dynamodb.process();\n};\n</code></pre>"},{"location":"dynamodb/","title":"DynamoDB","text":"<p>Event handler for Amazon DynamoDB Stream Events.</p>"},{"location":"dynamodb/#features","title":"\u2728 Features","text":"<ul> <li>Automatically convert DynamoDB JSON to standard JSON</li> <li>Only run on certain DynamoDB operations, like on when items are created, updated or deleted</li> <li>Able to validate DynamoDB record against a JSON Schema</li> <li>Assign Data Classes to records instead of getting raw DynamoDB JSON objects</li> </ul>"},{"location":"dynamodb/configurations/","title":"\u2699\ufe0f DynamoDB Event Configurations","text":"<p>The Dynamodb event will automatically handle many common things done when eventing off a DynamoDB stream. Developers then have the ability to further extend that functionality with custom middleware. Below is a full list of all the configurations available and examples of their use.</p> Examples <p>Don't like reading documentation? Then look at our examples, which can be deployed in 1 command into your AWS account! </p>"},{"location":"dynamodb/configurations/#configuration-options","title":"\ud83d\udee0\ufe0f Configuration Options","text":"option type required default description <code>before</code> func no null a custom function to be ran before your records are pulled <code>dataClass</code> class no null a custom class that will be passed instead of the records object <code>globalLogger</code> bool no false will assign the Acai logger to the global variable <code>globalLogger</code> <code>operations</code> array no ['create', 'update', 'delete'] will only run if record was created from the listed operation <code>operationError</code> bool no false will raise exception if operation of record is not from listed operations <code>requiredBody</code> str or obj no null will validate body of record against this schema <code>schemaPath</code> str no null file path pointing to the location of the openapi.yml file <code>validationError</code> bool no false will raise exception if validation of record fails"},{"location":"dynamodb/configurations/#example-dynamodb-configuration-options","title":"\ud83d\udca1 Example: DynamoDB Configuration Options","text":"<pre><code>import { DynamoDBStreamEvent } from 'aws-lambda';\nimport { Event } from 'acai-ts';\nimport { Grower } from './api/logic/grower';\n\nexport const handler = async (event: DynamoDBStreamEvent): Promise&lt;void&gt; =&gt; {\n    const options = {\n        globalLogger: true,\n        operations: ['create', 'update'], // [create, update, delete] by default\n        operationError: false, // will raise exception if wrong operation;  default false\n        requiredBody: 'ddb-record',\n        schemaPath: 'api/openapi.yml',\n        validationError: false, // will raise exception if validation fails;  default false\n        dataClass: Grower, // will get instance of this instead of record instance\n        before: (records: any[]) =&gt; {\n            // run this before records are sent\n        }\n    };\n    const eventClient = new Event.dynamodb(event, options);\n    const records = await eventClient.getRecords();\n    for (const grower of records) {\n        // do stuff here\n    }\n};\n</code></pre>"},{"location":"dynamodb/record/","title":"\ud83d\udcca DynamoDB Record Object","text":"<p>The DynamoDB event will by default provide instances of <code>record</code> classes which will be easier to work with then a standard lambda event record object. This is the same object which will be passed down to the <code>dataClass</code>, if you provide on in your configuration. Below is a list of all the properties and example outputs for the DynamoDB event record:</p> Examples <p>Don't like reading documentation? Then look at our examples, which can be deployed in 1 command into your AWS account! </p>"},{"location":"dynamodb/record/#record-properties","title":"\ud83d\udcdd Record Properties","text":"property type description <code>body</code> object the new image of dynamodb record; created or updated <code>created</code> float the approximate creationDate time <code>expired</code> bool whether the ttl has expired <code>id</code> str the id of the event which invoked the lambda <code>identity</code> object the identity who triggered the dynamodb change <code>keys</code> object the keys of DynamoDB record <code>name</code> str the name of the event which invoked the lambda <code>newImage</code> object the new image of dynamodb record; created or updated <code>oldImage</code> object the old image of dynamodb record; updated or deleted <code>operation</code> str triggered operation lambda (create, update, delete) <code>region</code> str the region the record is from <code>size</code> int the size in bytes of the record <code>source</code> str the source of the event which invoked the lambda <code>sourceARN</code> str the event source arn <code>streamType</code> str the stream view type <code>version</code> str the event version"},{"location":"dynamodb/record/#recordregion","title":"<code>record.region</code>","text":"<pre><code>console.log(record.region);\n\n// example output:\n'us-east-2'\n</code></pre>"},{"location":"dynamodb/record/#recordid","title":"<code>record.id</code>","text":"<pre><code>console.log(record.id);\n\n// example output:\n'9a37c0d03eb60f7cf70cabc823de9907'\n</code></pre>"},{"location":"dynamodb/record/#recordname","title":"<code>record.name</code>","text":"<pre><code>console.log(record.name);\n\n// example output:\n'INSERT'\n</code></pre>"},{"location":"dynamodb/record/#recordsource","title":"<code>record.source</code>","text":"<pre><code>console.log(record.source);\n\n// example output:\n'aws:dynamodb'\n</code></pre>"},{"location":"dynamodb/record/#recordkeys","title":"<code>record.keys</code>","text":"Info <p>This is converted from the original DDB JSON to standard json</p> <pre><code>console.log(record.keys);\n\n// example output:\n{\n    example_id: '123456789'\n}\n</code></pre>"},{"location":"dynamodb/record/#recordoldimage","title":"<code>record.oldImage</code>","text":"Info <p>This is converted from the original DDB JSON to standard json</p> <pre><code>console.log(record.oldImage);\n\n// example output:\n{\n    old_data: '123456789'\n}\n</code></pre>"},{"location":"dynamodb/record/#recordnewimage","title":"<code>record.newImage</code>","text":"Info <p>This is converted from the original DDB JSON to standard json</p> <pre><code>console.log(record.newImage);\n\n// example output:\n{\n    new_data: '123456789'\n}\n</code></pre>"},{"location":"dynamodb/record/#recordbody","title":"<code>record.body</code>","text":"Info <p>This is converted from the original DDB JSON to standard json from <code>newImage</code></p> <pre><code>console.log(record.body);\n\n// example output:\n{\n    new_data: '123456789'\n}\n</code></pre>"},{"location":"dynamodb/record/#recordoperation","title":"<code>record.operation</code>","text":"<pre><code>console.log(record.operation);\n\n// example output:\n'create'\n</code></pre>"},{"location":"dynamodb/record/#recordsourcearn","title":"<code>record.sourceARN</code>","text":"<pre><code>console.log(record.sourceARN);\n\n// example output:\n'arn:aws:dynamodb:us-east-1:771875143460:table/test-example/stream/2019-10-04T23:18:26.340'\n</code></pre>"},{"location":"dynamodb/record/#recordversion","title":"<code>record.version</code>","text":"<pre><code>console.log(record.version);\n\n// example output:\n'1.1'\n</code></pre>"},{"location":"dynamodb/record/#recordstreamtype","title":"<code>record.streamType</code>","text":"<pre><code>console.log(record.streamType);\n\n// example output:\n'NEW_AND_OLD_IMAGES'\n</code></pre>"},{"location":"dynamodb/record/#recordsize","title":"<code>record.size</code>","text":"<pre><code>console.log(record.size);\n\n// example output:\n1124\n</code></pre>"},{"location":"dynamodb/record/#recordcreated","title":"<code>record.created</code>","text":"<pre><code>console.log(record.created);\n\n// example output:\n1538695200.0 //unix timestamp\n</code></pre>"},{"location":"dynamodb/record/#recordidentity","title":"<code>record.identity</code>","text":"<pre><code>console.log(record.identity);\n\n// example output:\n{\n    type: 'Service',\n    principalId: 'dynamodb.amazonaws.com'\n}\n</code></pre>"},{"location":"dynamodb/record/#recordexpired","title":"<code>record.expired</code>","text":"<pre><code>console.log(record.expired);\n\n// example output:\nfalse\n</code></pre>"},{"location":"s3/","title":"S3","text":"<p>Event handler for Amazon S3 Bucket Events.</p>"},{"location":"s3/#features","title":"\u2728 Features","text":"<ul> <li>Automatically convert JSON files to JSON objects</li> <li>Automatically convert CSV files to JSON objects</li> <li>Only run on certain S3 operations, like on when items are created, updated or deleted</li> <li>Able to validate S3 record against a JSON Schema</li> <li>Assign Data Classes to records instead of getting raw S3 JSON objects</li> </ul>"},{"location":"s3/configurations/","title":"\u2699\ufe0f S3 Event Configurations","text":"<p>The S3 event will automatically handle many common things done when eventing off a S3 event. Developers then have the ability to further extend that functionality with custom middleware. Below is a full list of all the configurations available and examples of their use.</p> Examples <p>Don't like reading documentation? Then look at our examples, which can be deployed in 1 command into your AWS account! </p>"},{"location":"s3/configurations/#configuration-options","title":"\ud83d\udee0\ufe0f Configuration Options","text":"option type required default description <code>before</code> func no null a custom function to be ran before your records are pulled <code>dataClass</code> class no null a custom class that will be passed instead of the records object <code>getObject</code> bool no false will pull the file from S3 bucket and hold in memory <code>globalLogger</code> bool no false will assign the Acai logger to the global variable <code>globalLogger</code> <code>isJSON</code> bool no false will convert file into JSON object; requires <code>getObject</code> <code>isCSV</code> bool no false will convert file into CSV object; requires <code>getObject</code> <code>operations</code> array no ['create', 'update', 'delete'] will only run if record was created from the listed operation <code>operationError</code> bool no false will raise exception if operation of record is not from listed operations <code>requiredBody</code> str or obj no null will validate body of record against this schema, requires <code>isJSON</code> <code>schemaPath</code> str no null file path pointing to the location of the openapi.yml file <code>validationError</code> bool no false will raise exception if validation of record fails"},{"location":"s3/configurations/#example-s3-configuration-options","title":"\ud83d\udca1 Example: S3 Configuration Options","text":"<pre><code>import { S3Event } from 'aws-lambda';\nimport { Event } from 'acai-ts';\nimport { Grower } from './api/logic/grower';\n\nexport const handler = async (event: S3Event): Promise&lt;void&gt; =&gt; {\n    const options = {\n        globalLogger: true,\n        operations: ['create', 'delete'], // [create, update, delete] by default; s3 doesn't support delete\n        operationError: false, // will raise exception if wrong operation;  default false\n        requiredBody: 's3-record', // only works with isJSON\n        schemaPath: 'api/openapi.yml', // only works with isJSON\n        validationError: false, // will raise exception if validation fails;  default false\n        getObject: true, // required for isJSON or isCSV\n        isJSON: true, // will convert file into JSON object, must be valid JSON file\n        isCSV: false, // will convert file into object, must be valid CSV file\n        dataClass: Grower, // will get instance of this instead of record instance\n        before: (records: any[]) =&gt; {\n            // run this before records are sent\n        }\n    };\n    const eventClient = new Event.s3(event, options);\n    const records = await eventClient.getRecords();\n    for (const grower of records) {\n        // do stuff here\n    }\n};\n</code></pre>"},{"location":"s3/record/","title":"\ud83e\ude23 S3 Record Object","text":"<p>The S3 event will by default provide instances of <code>record</code> classes which will be easier to work with then standard lambda event record object. This is the same object which will be passed down to the <code>dataClass</code>, if you provide on in your configuration. Below is a list of all the properties and example outputs for the S3 event record:</p> Example <p>Don't like reading documentation? Then look at our examples which can be deployed in 1 command into your AWS account! </p>"},{"location":"s3/record/#record-properties","title":"\ud83d\udcdd Record Properties","text":"property type description <code>body</code> object the object from the bucket in memory; buffer, json or csv object <code>bucket</code> str the name of the bucket <code>id</code> str the id of configuration <code>key</code> str the bucket key <code>name</code> str the name of the event which invoked the lambda <code>object</code> object the object described from the bucket <code>operation</code> str triggered operation lambda (create, delete) <code>region</code> str the region the record is from <code>request</code> object the request parameters <code>response</code> object the response parameters <code>source</code> str the source of the event which invoked the lambda <code>time</code> float the event time <code>version</code> object the s3 schema version"},{"location":"s3/record/#recordregion","title":"<code>record.region</code>","text":"<pre><code>console.log(record.region);\n\n// example output:\n'us-east-2'\n</code></pre>"},{"location":"s3/record/#recordbody","title":"<code>record.body</code>","text":"<pre><code>console.log(record.body);\n\n// example output: depending on the configuration, it might be a Buffer, CSV, or JSON object\n// does require `getObject: true` to be set in the options of the EventClient\n</code></pre>"},{"location":"s3/record/#recordbucket","title":"<code>record.bucket</code>","text":"<pre><code>console.log(record.bucket);\n\n// example output:\n{\n    \"name\": \"DOC-EXAMPLE-BUCKET\",\n    \"ownerIdentity\": {\n        \"principalId\": \"A3I5XTEXAMAI3E\"\n    },\n    \"arn\": \"arn:aws:s3:::lambda-artifacts-deafc19498e3f2df\"\n}\n</code></pre>"},{"location":"s3/record/#recordid","title":"<code>record.id</code>","text":"<pre><code>console.log(record.id);\n\n// example output:\n'828aa6fc-f7b5-4305-8584-487c791949c1'\n</code></pre>"},{"location":"s3/record/#recordname","title":"<code>record.name</code>","text":"<pre><code>console.log(record.name);\n\n// example output:\n'ObjectCreated:Put'\n</code></pre>"},{"location":"s3/record/#recordsource","title":"<code>record.source</code>","text":"<pre><code>console.log(record.source);\n\n// example output:\n'aws:s3'\n</code></pre>"},{"location":"s3/record/#recordtime","title":"<code>record.time</code>","text":"<pre><code>console.log(record.time);\n\n// example output:\n'2019-09-03T19:37:27.192Z'\n</code></pre>"},{"location":"s3/record/#recordkey","title":"<code>record.key</code>","text":"<pre><code>console.log(record.key);\n\n// example output:\n'some-directory/b21b84d653bb07b05b1e6b33684dc11b.json'\n</code></pre>"},{"location":"s3/record/#recordobject","title":"<code>record.object</code>","text":"<pre><code>console.log(record.object);\n\n// example output:\n{\n    'key': 'some-directory/b21b84d653bb07b05b1e6b33684dc11b.json',\n    'size': 1305107,\n    'eTag': 'b21b84d653bb07b05b1e6b33684dc11b',\n    'sequencer': '0C0F6F405D6ED209E1'\n}\n</code></pre>"},{"location":"s3/record/#recordoperation","title":"<code>record.operation</code>","text":"<pre><code>console.log(record.operation);\n\n// example output:\n'create'\n</code></pre>"},{"location":"s3/record/#recordrequest","title":"<code>record.request</code>","text":"<pre><code>console.log(record.request);\n\n// example output:\n{\n    \"sourceIPAddress\": \"205.255.255.255\"\n}\n</code></pre>"},{"location":"s3/record/#recordresponse","title":"<code>record.response</code>","text":"<pre><code>console.log(record.response);\n\n// example output:\n{\n    \"x-amz-request-id\": \"D82B88E5F771F645\",\n    \"x-amz-id-2\": \"vlR7PnpV2Ce81l0PRw6jlUpck7Jo5ZsQjryTjKlc5aLWGVHPZLj5NeC6qMa0emYBDXOo6QBU0Wo=\"\n}\n</code></pre>"},{"location":"s3/record/#recordversion","title":"<code>record.version</code>","text":"<pre><code>console.log(record.version);\n\n// example output:\n\"1.0\"\n</code></pre>"},{"location":"sqs/","title":"SNS/SQS","text":"<p>Event handler for Amazon SNS/SQS Events.</p>"},{"location":"sqs/#features","title":"\u2728 Features","text":"<ul> <li>Automatically convert JSON from message body</li> <li>Automatically flatten message attributes</li> <li>Able to message body against a JSON Schema</li> <li>Assign Data Classes to records instead of getting record objects</li> </ul>"},{"location":"sqs/configurations/","title":"\u2699\ufe0f SNS/SQS Event Configurations","text":"<p>The SNS/SQS event will automatically handle many common things done when eventing off an SNS/SQS stream. Developers then have the ability to further extend that functionality with custom middleware. Below is a full list of all the configurations available and examples of their use.</p> Examples <p>Don't like reading documentation? Then look at our examples, which can be deployed in 1 command into your AWS account! </p>"},{"location":"sqs/configurations/#configuration-options","title":"\ud83d\udee0\ufe0f Configuration Options","text":"option type required default description <code>before</code> func no null a custom function to be ran before your records are pulled <code>dataClass</code> class no null a custom class that will be passed instead of the records object <code>globalLogger</code> bool no false will assign the Acai logger to the global variable <code>globalLogger</code> <code>requiredBody</code> str or obj no null will validate body of record against this schema <code>schemaPath</code> str no null file path pointing to the location of the openapi.yml file <code>validationError</code> bool no false will raise exception if validation of record fails"},{"location":"sqs/configurations/#example-snssqs-configuration-options","title":"\ud83d\udca1 Example: SNS/SQS Configuration Options","text":"<pre><code>import { SQSEvent } from 'aws-lambda';\nimport { Event } from 'acai-ts';\nimport { Grower } from './api/logic/grower';\n\nexport const handler = async (event: SQSEvent): Promise&lt;void&gt; =&gt; {\n    const options = {\n        globalLogger: true,\n        requiredBody: 'sqs-record',\n        schemaPath: 'api/openapi.yml',\n        validationError: false, // will raise exception if validation fails;  default false\n        dataClass: Grower, // will get instance of this instead of record instance\n        before: (records: any[]) =&gt; {\n            // run this before records are sent\n        }\n    };\n    const eventClient = new Event.sqs(event, options);\n    const records = await eventClient.getRecords();\n    for (const grower of records) {\n        // do stuff here\n    }\n};\n</code></pre>"},{"location":"sqs/record/","title":"\ud83d\udcec SNS/SQS Record Object","text":"<p>The SNS/SQS event will by default provide instances of <code>record</code> classes which will be easier to work with then a standard lambda event record object. This is the same object which will be passed down to the <code>dataClass</code>, if you provide on in your configuration. Below is a list of all the properties and example outputs for the SNS/SQS event record:</p> Examples <p>Don't like reading documentation? Then look at our examples, which can be deployed in 1 command into your AWS account! </p>"},{"location":"sqs/record/#record-properties","title":"\ud83d\udcdd Record Properties","text":"property type description <code>attributes</code> object the attributes of the message <code>body</code> object the object from the bucket in memory; decodes json automatically <code>id</code> str the id of message <code>md5</code> str the message in an md4 hash format <code>messageAttributes</code> object the attributes of the message, flattened <code>raw</code> any the body of the message as is, no conversion <code>receiptHandle</code> str the handle of the receipt <code>region</code> str the region of the message <code>source</code> str the source of the event which invoked the lambda <code>sourceARN</code> str the arn of the source"},{"location":"sqs/record/#recordattributes","title":"<code>record.attributes</code>","text":"<pre><code>console.log(record.attributes);\n\n// example output:\n{\n    \"ApproximateReceiveCount\": \"1\",\n    \"SentTimestamp\": \"1545082650636\",\n    \"SenderId\": \"AIDAIENQZJOLO23YVJ4VO\",\n    \"ApproximateFirstReceiveTimestamp\": \"1545082650649\"\n}\n</code></pre>"},{"location":"sqs/record/#recordbody","title":"<code>record.body</code>","text":"<pre><code>console.log(record.body);\n\n// example output:\n{\n    some_key: 'some_value'\n}\n</code></pre>"},{"location":"sqs/record/#recordsource","title":"<code>record.source</code>","text":"<pre><code>console.log(record.source);\n\n// example output:\n'aws:sqs'\n</code></pre>"},{"location":"sqs/record/#recordmd5","title":"<code>record.md5</code>","text":"<pre><code>console.log(record.md5);\n\n// example output:\n'e4e68fb7bd0e697a0ae8f1bb342846b3'\n</code></pre>"},{"location":"sqs/record/#recordmessageattributes","title":"<code>record.messageAttributes</code>","text":"<pre><code>console.log(record.messageAttributes);\n\n// example output:\n{\n    some_attribute_key: 'some_attribute_value'\n}\n</code></pre>"},{"location":"sqs/record/#recordid","title":"<code>record.id</code>","text":"<pre><code>console.log(record.id);\n\n// example output:\n'2e1424d4-f796-459a-8184-9c92662be6da'\n</code></pre>"},{"location":"sqs/record/#recordraw","title":"<code>record.raw</code>","text":"<pre><code>console.log(record.raw);\n\n// example output:\n'{\"some_key\": \"some_value\"}'\n</code></pre>"},{"location":"sqs/record/#recordreceipthandle","title":"<code>record.receiptHandle</code>","text":"<pre><code>console.log(record.receiptHandle);\n\n// example output:\n'AQEBzWwaftRI0KuVm4tP+/7q1rGgNqicHq...'\n</code></pre>"},{"location":"sqs/record/#recordregion","title":"<code>record.region</code>","text":"<pre><code>console.log(record.region);\n\n// example output:\n'us-east-2'\n</code></pre>"},{"location":"sqs/record/#recordsourcearn","title":"<code>record.sourceARN</code>","text":"<pre><code>console.log(record.sourceARN);\n\n// example output:\n'arn:aws:sqs:us-east-2:123456789012:my-queue'\n</code></pre>"},{"location":"usage/","title":"Usage Patterns","text":"<p>Acai-TS offers two powerful patterns for defining API Gateway endpoints, each with its own strengths and ideal use cases.</p>"},{"location":"usage/#pattern-overview","title":"Pattern Overview","text":""},{"location":"usage/#functional-pattern","title":"\ud83d\udd27 Functional Pattern","text":"<p>Configuration-driven approach using exported functions with requirements objects</p> <pre><code>// File: src/handlers/users.ts\nexport const requirements = {\n  post: {\n    requiredBody: 'CreateUserRequest',\n    before: [authMiddleware],\n    timeout: 5000\n  }\n};\n\nexport const post = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n  // Handler logic\n  response.body = { id: '123', ...request.body };\n  return response;\n};\n</code></pre> <p>\u2705 Best for: - Teams who prefer explicit configuration objects - JavaScript codebases transitioning to TypeScript - Reusable middleware configurations - Runtime configuration changes - Developers familiar with traditional frameworks</p>"},{"location":"usage/#decorator-pattern","title":"\ud83c\udfa8 Decorator Pattern","text":"<p>Annotation-style approach using TypeScript decorators on class methods</p> <pre><code>// File: src/handlers/users.ts\nexport class UsersEndpoint extends BaseEndpoint {\n  @Validate({ requiredBody: 'CreateUserRequest' })\n  @Before(authMiddleware)\n  @Timeout(5000)\n  async post(request: Request, response: Response): Promise&lt;Response&gt; {\n    // Handler logic\n    response.body = { id: '123', ...request.body };\n    return response;\n  }\n}\n</code></pre> <p>\u2705 Best for: - TypeScript-first development - Teams who love declarative annotations - Method-level configuration preferences - Clean, co-located configuration with handlers - Modern TypeScript codebases</p>"},{"location":"usage/#key-similarities","title":"Key Similarities","text":"<p>Both patterns share the same core features:</p> <ul> <li>\ud83d\uddc2\ufe0f File-based routing - Routes determined by file structure</li> <li>\ud83d\udd0d Schema validation - OpenAPI and JSON Schema support</li> <li>\ud83d\udd10 Authentication - Global and method-level auth controls</li> <li>\ud83d\udd04 Middleware - Before/after processing hooks</li> <li>\u23f1\ufe0f Timeouts - Request timeout management</li> <li>\ud83d\udcdd Type safety - Full TypeScript support</li> </ul>"},{"location":"usage/#quick-comparison","title":"Quick Comparison","text":"Feature Functional Decorators Configuration Style Object-based Annotation-based TypeScript Required No (works with JS) Yes Learning Curve Lower Moderate Runtime Changes Easy Limited Co-location Separate Inline Reusability High Moderate"},{"location":"usage/#file-structure-both-patterns","title":"File Structure (Both Patterns)","text":"<p>Both patterns use identical file-based routing:</p> <pre><code>src/handlers/\n\u251c\u2500\u2500 users.ts              \u2192 /users\n\u251c\u2500\u2500 users/{id}.ts         \u2192 /users/{id}\n\u251c\u2500\u2500 products/\n\u2502   \u251c\u2500\u2500 index.ts          \u2192 /products\n\u2502   \u2514\u2500\u2500 {id}/reviews.ts   \u2192 /products/{id}/reviews\n\u2514\u2500\u2500 health.ts             \u2192 /health\n</code></pre>"},{"location":"usage/#router-configuration-both-patterns","title":"Router Configuration (Both Patterns)","text":"<p>Both patterns use the same router setup:</p> <pre><code>import { Router } from 'acai-ts';\nimport { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\n\nconst router = new Router({\n  basePath: '/api/v1',\n  routesPath: './src/handlers/**/*.ts',\n  schemaPath: './openapi.yml',\n  withAuth: async (request, response) =&gt; {\n    // Global auth middleware\n  }\n});\n\nexport const handler = async (\n  event: APIGatewayProxyEvent\n): Promise&lt;APIGatewayProxyResult&gt; =&gt; {\n  return await router.route(event);\n};\n</code></pre>"},{"location":"usage/#migration-between-patterns","title":"Migration Between Patterns","text":"<p>You can easily migrate between patterns since they're functionally equivalent:</p> <pre><code>// Functional \u2192 Decorators\nexport const requirements = { post: { requiredBody: 'User' } };\nexport const post = async (req, res) =&gt; { /* logic */ };\n\n// Becomes:\nexport class UsersEndpoint extends BaseEndpoint {\n  @Validate({ requiredBody: 'User' })\n  async post(req, res) { /* same logic */ }\n}\n</code></pre>"},{"location":"usage/#which-pattern-should-you-choose","title":"Which Pattern Should You Choose?","text":""},{"location":"usage/#choose-functional-if-you","title":"Choose Functional if you:","text":"<ul> <li>\ud83d\udd27 Prefer explicit configuration objects</li> <li>\ud83d\udce6 Want maximum reusability of middleware configs</li> <li>\ud83d\udd04 Need runtime configuration changes</li> <li>\ud83d\udc65 Have mixed JS/TS team members</li> <li>\ud83c\udfd7\ufe0f Are migrating from traditional frameworks</li> </ul>"},{"location":"usage/#choose-decorators-if-you","title":"Choose Decorators if you:","text":"<ul> <li>\ud83c\udfa8 Love clean, declarative annotations</li> <li>\ud83d\udd17 Want configuration co-located with methods</li> <li>\ud83d\udc8e Are building pure TypeScript applications</li> <li>\ud83c\udd95 Starting fresh with modern patterns</li> <li>\ud83d\udcdd Prefer method-level configuration visibility</li> </ul>"},{"location":"usage/#next-steps","title":"Next Steps","text":"<ul> <li>Functional Pattern Guide \u2192 - Learn the requirements object approach</li> <li>Decorator Pattern Guide \u2192 - Master TypeScript decorators</li> <li>Event Processing \u2192 - Handle DynamoDB, S3, and SQS events</li> </ul> <p>Both patterns are powerful and well-supported. Choose based on your team's preferences and project requirements!</p>"},{"location":"usage/decorators/","title":"\ud83c\udfa8 Decorator Pattern","text":"<p>Acai-TS provides a powerful decorator-based approach for defining routes, middleware, and validation. Decorators offer a clean, declarative way to configure your endpoints without boilerplate code.</p> TypeScript Configuration Required <p>To use decorators, ensure your <code>tsconfig.json</code> includes: <pre><code>{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"target\": \"ES2020\"\n  }\n}\n</code></pre></p>"},{"location":"usage/decorators/#quick-start","title":"\ud83d\ude80 Quick Start","text":"<pre><code>import 'reflect-metadata';\nimport { BaseEndpoint, Validate, Auth, Before, After, Timeout, Response, Request } from 'acai-ts';\n\n// File: src/handlers/users/{id}.ts\n// Maps to GET/PUT/DELETE /users/{id}\nexport class UserEndpoint extends BaseEndpoint {\n  @Auth()\n  @Timeout(5000)\n  async get(request: Request, response: Response): Promise&lt;Response&gt; {\n    response.body = { id: request.pathParameters.id, name: 'John Doe' };\n    return response;\n  }\n}\n\n// File: src/handlers/users.ts  \n// Maps to GET/POST /users\nexport class UsersEndpoint extends BaseEndpoint {\n  @Validate({\n    requiredBody: 'CreateUserRequest'\n  })\n  @Before(async (request: Request, response: Response) =&gt; {\n    console.log('Creating user:', request.body.email);\n  })\n  @After(async (request: Request, response: Response) =&gt; {\n    console.log('User created successfully');\n  })\n  async post(request: Request, response: Response): Promise&lt;Response&gt; {\n    const { name, email } = request.body;\n    response.code = 201;\n    response.body = { id: Math.random(), name, email };\n    return response;\n  }\n}\n</code></pre>"},{"location":"usage/decorators/#available-decorators","title":"\ud83c\udff7\ufe0f Available Decorators","text":""},{"location":"usage/decorators/#file-based-routing-no-route-decorator","title":"\ud83d\udcc1 File-Based Routing (No @Route Decorator)","text":"<p>Acai-TS uses file-based routing instead of <code>@Route</code> decorators. Routes are determined by your file structure:</p> <p>File Structure \u2192 Routes: <pre><code>src/handlers/\n\u251c\u2500\u2500 users.ts              \u2192 /users (GET, POST, PUT, DELETE)\n\u251c\u2500\u2500 users/{id}.ts         \u2192 /users/{id} (GET, PUT, DELETE)\n\u2514\u2500\u2500 products/index.ts     \u2192 /products\n</code></pre></p> <p>HTTP Methods: Define methods in your <code>BaseEndpoint</code> class: <pre><code>export class UsersEndpoint extends BaseEndpoint {\n  async get(request: Request, response: Response): Promise&lt;Response&gt; { /* GET /users */ }\n  async post(request: Request, response: Response): Promise&lt;Response&gt; { /* POST /users */ }\n  async put(request: Request, response: Response): Promise&lt;Response&gt; { /* PUT /users */ }\n  async delete(request: Request, response: Response): Promise&lt;Response&gt; { /* DELETE /users */ }\n}\n</code></pre></p>"},{"location":"usage/decorators/#validate","title":"\u2713 @Validate","text":"<p>Adds request validation using OpenAPI schemas or JSON Schema.</p> <pre><code>@Validate(validationConfig: ValidationConfig)\n</code></pre> <p>Examples: <pre><code>// OpenAPI schema reference\n@Validate({ requiredBody: 'CreateUserRequest' })\n\n// Required headers\n@Validate({ requiredHeaders: ['x-api-key', 'authorization'] })\n\n// Required query parameters  \n@Validate({ requiredQuery: ['page', 'limit'] })\n\n// Direct JSON Schema\n@Validate({\n  body: {\n    type: 'object',\n    required: ['name', 'email'],\n    properties: {\n      name: { type: 'string', minLength: 2, maxLength: 50 },\n      email: { type: 'string', format: 'email' }\n    }\n  }\n})\n\n// Multiple validations\n@Validate({\n  requiredBody: 'CreateUserRequest',\n  requiredHeaders: ['authorization']\n})\n</code></pre></p>"},{"location":"usage/decorators/#auth","title":"\ud83d\udd10 @Auth","text":"<p>Marks a method as requiring authentication using the router's global <code>withAuth</code> middleware.</p> <pre><code>@Auth(required?: boolean)\n</code></pre> <p>Setup Router with Auth Middleware: <pre><code>const router = new Router({\n  basePath: '/api/v1',\n  routesPath: './src/handlers/**/*.ts',\n  withAuth: async (request: Request, response: Response) =&gt; {\n    const token = request.headers.authorization?.replace('Bearer ', '');\n    if (!token || !validateJWT(token)) {\n      response.code = 401;\n      response.setError('auth', 'Invalid or missing authentication token');\n    }\n  }\n});\n</code></pre></p> <p>Examples: <pre><code>export class UsersEndpoint extends BaseEndpoint {\n  @Auth()  // Requires authentication (default: required=true)\n  async get(request: Request, response: Response): Promise&lt;Response&gt; {\n    response.body = { users: [] };\n    return response;\n  }\n\n  @Auth(false)  // Explicitly disable auth requirement\n  async post(request: Request, response: Response): Promise&lt;Response&gt; {\n    response.body = { message: 'Public endpoint' };\n    return response;\n  }\n\n  // No @Auth decorator = no auth requirement\n  async options(request: Request, response: Response): Promise&lt;Response&gt; {\n    response.body = { message: 'CORS preflight' };\n    return response;\n  }\n}\n</code></pre></p>"},{"location":"usage/decorators/#before","title":"\u2b05\ufe0f @Before","text":"<p>Adds middleware that runs before the main handler.</p> <pre><code>@Before(middleware1, middleware2, ...)\n</code></pre> <p>Examples: <pre><code>// Single middleware\nconst logRequest = async (request: Request, response: Response) =&gt; {\n  console.log(`${request.method} ${request.path} - ${new Date().toISOString()}`);\n};\n\n@Before(logRequest)\nasync get(request: Request, response: Response): Promise&lt;Response&gt; {\n  // Handler code\n}\n\n// Multiple middlewares (execute in order)\nconst rateLimiter = async (request: Request, response: Response) =&gt; {\n  const clientIp = request.headers['x-forwarded-for'] || 'unknown';\n  if (await isRateLimited(clientIp)) {\n    response.code = 429;\n    response.setError('rate_limit', 'Too many requests');\n  }\n};\n\nconst authCheck = async (request: Request, response: Response) =&gt; {\n  if (!request.headers.authorization) {\n    response.code = 401;\n    response.setError('auth', 'Unauthorized');\n  }\n};\n\n@Before(rateLimiter, authCheck)  // Executes: rateLimiter \u2192 authCheck \u2192 handler\nasync post(request: Request, response: Response): Promise&lt;Response&gt; {\n  // Handler code\n}\n</code></pre></p>"},{"location":"usage/decorators/#after","title":"\u27a1\ufe0f @After","text":"<p>Adds middleware that runs after the main handler.</p> <pre><code>@After(middleware1, middleware2, ...)\n</code></pre> <p>Examples: <pre><code>// Single middleware\nconst addTimestamp = async (request: Request, response: Response) =&gt; {\n  response.body.timestamp = new Date().toISOString();\n};\n\n@After(addTimestamp)\nasync get(request: Request, response: Response): Promise&lt;Response&gt; {\n  response.body = { data: 'value' };\n  return response;\n}\n\n// Multiple middlewares (execute in order)\nconst addSecurityHeaders = async (request: Request, response: Response) =&gt; {\n  response.setHeader('X-Content-Type-Options', 'nosniff');\n  response.setHeader('X-Frame-Options', 'DENY');\n};\n\nconst sanitizeResponse = async (request: Request, response: Response) =&gt; {\n  if (response.body?.users) {\n    response.body.users = response.body.users.map(user =&gt; ({\n      ...user,\n      password: undefined // Remove sensitive data\n    }));\n  }\n};\n\n@After(addSecurityHeaders, sanitizeResponse)  // Executes: handler \u2192 addSecurityHeaders \u2192 sanitizeResponse\nasync get(request: Request, response: Response): Promise&lt;Response&gt; {\n  // Handler code\n}\n</code></pre></p>"},{"location":"usage/decorators/#timeout","title":"\u23f1\ufe0f @Timeout","text":"<p>Sets a timeout for the endpoint.</p> <pre><code>@Timeout(milliseconds: number)\n</code></pre> <p>Examples: <pre><code>@Timeout(5000)  // 5 second timeout\n@Timeout(30000) // 30 second timeout for heavy operations\n@Timeout(1000)  // 1 second timeout for quick operations\n</code></pre></p>"},{"location":"usage/decorators/#combining-decorators","title":"\ud83e\udd1d Combining Decorators","text":"<p>Decorators can be combined and will execute in the following order:</p> <ol> <li>@Before - Custom middleware (runs first)</li> <li>@Auth - Authentication check (router's <code>withAuth</code> middleware)</li> <li>@Validate - Request validation</li> <li>Handler - Your main function with <code>@Timeout</code></li> <li>@After - Post-processing middleware</li> </ol> <pre><code>// File: src/handlers/orders.ts\nconst enrichOrder = async (request: Request, response: Response) =&gt; {\n  request.body.orderId = generateOrderId();\n  request.body.timestamp = Date.now();\n};\n\nconst sendConfirmation = async (request: Request, response: Response) =&gt; {\n  await sendOrderConfirmation(response.body.orderId);\n};\n\nexport class OrdersEndpoint extends BaseEndpoint {\n  @Before(enrichOrder)        // Runs first\n  @Auth()                     // Auth middleware runs after Before\n  @Validate({                 // Validates request\n    requiredBody: 'CreateOrderRequest'\n  })\n  @Timeout(10000)            // Sets timeout\n  @After(sendConfirmation)   // Runs last\n  async post(request: Request, response: Response): Promise&lt;Response&gt; {\n    const order = await processOrder(request.body);\n    response.code = 201;\n    response.body = order;\n    return response;\n  }\n}\n</code></pre>"},{"location":"usage/decorators/#router-configuration-for-decorators","title":"\ud83c\udf10 Router Configuration for Decorators","text":"<p>Configure your router for file-based routing with decorators:</p> <pre><code>import 'reflect-metadata';\nimport { Router } from 'acai-ts';\nimport { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\n\nconst router = new Router({\n  basePath: '/api/v1',\n  routesPath: './src/handlers/**/*.ts',  // File-based routing\n  schemaPath: './openapi.yml',           // Optional: OpenAPI validation\n  timeout: 30000,\n  outputError: true,\n  withAuth: async (request, response) =&gt; { // Global auth middleware\n    // Your JWT validation logic here\n    const token = request.headers.authorization?.replace('Bearer ', '');\n    if (!token || !validateJWT(token)) {\n      response.code = 401;\n      response.setError('auth', 'Invalid or missing authentication token');\n    }\n  }\n});\n\nexport const handler = async (\n  event: APIGatewayProxyEvent\n): Promise&lt;APIGatewayProxyResult&gt; =&gt; {\n  return await router.route(event);\n};\n</code></pre>"},{"location":"usage/decorators/#best-practices","title":"\ud83c\udf1f Best Practices","text":""},{"location":"usage/decorators/#1-keep-auth-simple","title":"1\ufe0f\u20e3 Keep Auth Simple","text":"<pre><code>// \u2705 Good - Use @Auth as boolean flag\n@Auth()  // Uses router's withAuth middleware\n@Auth(false)  // Explicitly disable auth\n\n// \u274c Avoid - @Auth doesn't take functions (that's the old API)\n// @Auth(async (request) =&gt; { /* complex logic */ })\n// Instead, put complex logic in router's withAuth middleware\n</code></pre>"},{"location":"usage/decorators/#2-use-multiple-beforeafter-for-different-concerns","title":"2\ufe0f\u20e3 Use Multiple @Before/@After for Different Concerns","text":"<pre><code>// \u2705 Good - Separate concerns\n@Before(logRequest)\n@Before(validateBusinessRules)\n@Before(enrichRequestData)\n\n// \u274c Avoid - Single decorator doing everything\n@Before(async (request) =&gt; {\n  // logging + validation + enrichment all in one\n})\n</code></pre>"},{"location":"usage/decorators/#3-consistent-error-handling","title":"3\ufe0f\u20e3 Consistent Error Handling","text":"<pre><code>// Handle errors in middleware functions\nconst authMiddleware = async (request: Request, response: Response) =&gt; {\n  try {\n    const token = request.headers.authorization?.replace('Bearer ', '');\n    if (!token || !await validateToken(token)) {\n      response.code = 401;\n      response.setError('auth', 'Invalid authentication');\n    }\n  } catch (error) {\n    console.error('Auth error:', error);\n    response.code = 401;\n    response.setError('auth', 'Authentication failed');\n  }\n};\n\n@Before(authMiddleware)  // Use in @Before instead of @Auth for complex logic\n</code></pre>"},{"location":"usage/decorators/#4-type-safety","title":"4\ufe0f\u20e3 Type Safety","text":"<pre><code>interface CreateUserRequest {\n  name: string;\n  email: string;\n  age?: number;\n}\n\n// File: src/handlers/users.ts\nexport class UsersEndpoint extends BaseEndpoint {\n  @Validate({\n    body: {\n      type: 'object',\n      required: ['name', 'email'],\n      properties: {\n        name: { type: 'string' },\n        email: { type: 'string', format: 'email' },\n        age: { type: 'integer', minimum: 0 }\n      }\n    }\n  })\n  async post(request: Request, response: Response): Promise&lt;Response&gt; {\n    // TypeScript knows request.body is CreateUserRequest when properly typed\n    const { name, email, age } = request.body as CreateUserRequest;\n    response.body = { id: 123, name, email, age };\n    return response;\n  }\n}\n</code></pre>"},{"location":"usage/decorators/#migration-from-functional-approach","title":"\ud83d\udd04 Migration from Functional Approach","text":""},{"location":"usage/decorators/#before-functional-pattern","title":"\ud83d\udd34 Before (Functional Pattern)","text":"<pre><code>export const requirements = {\n  post: {\n    before: [authMiddleware],\n    requiredBody: 'CreateUserSchema',\n    timeout: 5000\n  }\n};\n\nexport const post = async (request: Request, response: Response) =&gt; {\n  response.body = { id: 123, ...request.body };\n  return response;\n};\n</code></pre>"},{"location":"usage/decorators/#after-class-based-with-decorators","title":"\ud83d\udfe2 After (Class-Based with Decorators)","text":"<pre><code>// File: src/handlers/users.ts\nexport class UsersEndpoint extends BaseEndpoint {\n  @Auth()  // Uses router's withAuth middleware\n  @Validate({ requiredBody: 'CreateUserSchema' })\n  @Timeout(5000)\n  async post(request: Request, response: Response): Promise&lt;Response&gt; {\n    response.body = { id: 123, ...request.body };\n    return response;\n  }\n}\n</code></pre>"},{"location":"usage/decorators/#common-patterns","title":"\ud83d\udce6 Common Patterns","text":""},{"location":"usage/decorators/#crud-operations","title":"\ud83d\udcdd CRUD Operations","text":"<pre><code>// File: src/handlers/users.ts - Handles /users\nexport class UsersEndpoint extends BaseEndpoint {\n  @Auth()\n  async get(request: Request, response: Response): Promise&lt;Response&gt; {\n    const users = await getUserList();\n    response.body = { users };\n    return response;\n  }\n\n  @Auth()\n  @Validate({ requiredBody: 'CreateUserSchema' })\n  async post(request: Request, response: Response): Promise&lt;Response&gt; {\n    const user = await createUser(request.body);\n    response.code = 201;\n    response.body = user;\n    return response;\n  }\n}\n\n// File: src/handlers/users/{id}.ts - Handles /users/{id}\nexport class UserEndpoint extends BaseEndpoint {\n  @Auth()\n  async get(request: Request, response: Response): Promise&lt;Response&gt; {\n    const user = await getUserById(request.pathParameters.id);\n    response.body = user;\n    return response;\n  }\n\n  @Auth()\n  @Validate({ requiredBody: 'UpdateUserSchema' })\n  async put(request: Request, response: Response): Promise&lt;Response&gt; {\n    const user = await updateUser(request.pathParameters.id, request.body);\n    response.body = user;\n    return response;\n  }\n\n  @Auth()\n  async delete(request: Request, response: Response): Promise&lt;Response&gt; {\n    await deleteUser(request.pathParameters.id);\n    response.code = 204;\n    return response;\n  }\n}\n</code></pre> <p>For more detailed examples and advanced usage patterns, see our troubleshooting guide and the example code on GitHub.</p>"},{"location":"usage/functional/","title":"\ud83d\udd27 Functional Pattern","text":"<p>Acai-TS supports a functional pattern that uses exported functions with a <code>requirements</code> object for configuration. This pattern is ideal for developers who prefer a more traditional, configuration-driven approach over decorators.</p> TypeScript Configuration <p>The functional pattern works with standard TypeScript - no special decorator configuration required.</p>"},{"location":"usage/functional/#quick-start","title":"\ud83d\ude80 Quick Start","text":"<pre><code>import { Router, Response, Request } from 'acai-ts';\nimport { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\n\n// File: src/handlers/users.ts\n// Maps to /users based on file structure\n\n// Define requirements for each HTTP method\nexport const requirements = {\n  get: {\n    before: [authMiddleware],\n    requiredHeaders: ['x-api-key']\n  },\n  post: {\n    requiredBody: 'CreateUserRequest',\n    before: [authMiddleware, validationMiddleware],\n    after: [loggingMiddleware],\n    timeout: 5000\n  }\n};\n\n// Define middleware functions\nconst authMiddleware = async (request: Request, response: Response) =&gt; {\n  if (!request.headers.authorization) {\n    response.code = 401;\n    response.setError('auth', 'Unauthorized');\n  }\n};\n\nconst validationMiddleware = async (request: Request, response: Response) =&gt; {\n  // Custom validation logic\n};\n\nconst loggingMiddleware = async (request: Request, response: Response) =&gt; {\n  console.log('User operation completed');\n};\n\n// Define HTTP method handlers\nexport const get = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n  response.body = { users: [] };\n  return response;\n};\n\nexport const post = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n  const user = await createUser(request.body);\n  response.code = 201;\n  response.body = user;\n  return response;\n};\n\n// Lambda handler\nexport const handler = async (\n  event: APIGatewayProxyEvent\n): Promise&lt;APIGatewayProxyResult&gt; =&gt; {\n  const router = new Router({\n    basePath: '/api/v1',\n    routesPath: './src/handlers/**/*.ts',\n    schemaPath: './openapi.yml' // Optional: OpenAPI validation\n  });\n\n  return await router.route(event);\n};\n</code></pre>"},{"location":"usage/functional/#file-based-routing","title":"\ud83d\udcc1 File-Based Routing","text":"<p>The functional pattern uses the same file-based routing as the decorator pattern:</p> <p>File Structure \u2192 Routes: <pre><code>src/handlers/\n\u251c\u2500\u2500 users.ts              \u2192 /users (GET, POST, PUT, DELETE)\n\u251c\u2500\u2500 users/{id}.ts         \u2192 /users/{id} (GET, PUT, DELETE)\n\u2514\u2500\u2500 products/index.ts     \u2192 /products\n</code></pre></p> <p>HTTP Methods: Export functions matching HTTP method names: <pre><code>// In any handler file\nexport const get = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; { /* GET handler */ };\nexport const post = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; { /* POST handler */ };\nexport const put = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; { /* PUT handler */ };\nexport const patch = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; { /* PATCH handler */ };\nexport const delete = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; { /* DELETE handler */ };\n</code></pre></p>"},{"location":"usage/functional/#requirements-object","title":"\ud83d\udccb Requirements Object","text":"<p>The <code>requirements</code> object defines configuration for each HTTP method:</p>"},{"location":"usage/functional/#basic-structure","title":"\ud83c\udfe0 Basic Structure","text":"<pre><code>export const requirements = {\n  [httpMethod]: {\n    // Configuration options\n  }\n};\n</code></pre>"},{"location":"usage/functional/#available-options","title":"\u2699\ufe0f Available Options","text":""},{"location":"usage/functional/#validation","title":"\u2713 Validation","text":"<pre><code>export const requirements = {\n  post: {\n    // OpenAPI schema reference\n    requiredBody: 'CreateUserRequest',\n\n    // Required headers\n    requiredHeaders: ['x-api-key', 'authorization'],\n\n    // Required query parameters\n    requiredQuery: ['page', 'limit'],\n\n    // Direct JSON Schema\n    body: {\n      type: 'object',\n      required: ['name', 'email'],\n      properties: {\n        name: { type: 'string' },\n        email: { type: 'string', format: 'email' }\n      }\n    }\n  }\n};\n</code></pre>"},{"location":"usage/functional/#middleware","title":"\ud83d\udee1\ufe0f Middleware","text":"<pre><code>const middleware1 = async (request: Request, response: Response) =&gt; {\n  // Pre-processing logic\n};\n\nconst middleware2 = async (request: Request, response: Response) =&gt; {\n  // Post-processing logic\n};\n\nexport const requirements = {\n  get: {\n    before: [middleware1],        // Runs before handler\n    after: [middleware2]          // Runs after handler\n  },\n  post: {\n    before: [middleware1, middleware2], // Multiple middleware (execute in order)\n    after: [middleware2]\n  }\n};\n</code></pre>"},{"location":"usage/functional/#timeout","title":"\u23f1\ufe0f Timeout","text":"<pre><code>export const requirements = {\n  post: {\n    timeout: 5000    // 5 second timeout\n  },\n  get: {\n    timeout: 30000   // 30 second timeout for heavy operations\n  }\n};\n</code></pre>"},{"location":"usage/functional/#authentication","title":"\ud83d\udd10 Authentication","text":"<pre><code>export const requirements = {\n  get: {\n    auth: true    // Requires authentication (uses router's withAuth middleware)\n  },\n  post: {\n    auth: false   // Explicitly disable auth requirement\n  }\n  // No auth property = no auth requirement\n};\n</code></pre>"},{"location":"usage/functional/#complete-examples","title":"\ud83d\udcda Complete Examples","text":""},{"location":"usage/functional/#user-management-api","title":"\ud83d\udc64 User Management API","text":"<pre><code>// File: src/handlers/users.ts\nimport { Response, Request } from 'acai-ts';\n\n// Middleware functions\nconst authMiddleware = async (request: Request, response: Response) =&gt; {\n  if (!request.headers.authorization) {\n    response.code = 401;\n    response.setError('auth', 'Unauthorized');\n  }\n};\n\nconst logRequest = async (request: Request, response: Response) =&gt; {\n  console.log(`${request.method} ${request.path} - ${new Date().toISOString()}`);\n};\n\nconst addTimestamp = async (request: Request, response: Response) =&gt; {\n  if (typeof response.body === 'object') {\n    response.body.timestamp = new Date().toISOString();\n  }\n};\n\n// Requirements configuration\nexport const requirements = {\n  get: {\n    before: [logRequest, authMiddleware],\n    after: [addTimestamp]\n  },\n  post: {\n    requiredBody: 'CreateUserRequest',\n    before: [logRequest, authMiddleware],\n    after: [addTimestamp],\n    timeout: 5000\n  },\n  put: {\n    requiredBody: 'UpdateUserRequest',\n    requiredHeaders: ['authorization'],\n    before: [authMiddleware],\n    timeout: 10000\n  }\n};\n\n// HTTP method handlers\nexport const get = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n  const users = await getUserList();\n  response.body = { users };\n  return response;\n};\n\nexport const post = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n  const user = await createUser(request.body);\n  response.code = 201;\n  response.body = user;\n  return response;\n};\n\nexport const put = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n  const user = await updateUser(request.body);\n  response.body = user;\n  return response;\n};\n</code></pre>"},{"location":"usage/functional/#user-detail-api","title":"\ud83d\udd0d User Detail API","text":"<pre><code>// File: src/handlers/users/{id}.ts\nimport { Response, Request } from 'acai-ts';\n\nconst authMiddleware = async (request: Request, response: Response) =&gt; {\n  if (!request.headers.authorization) {\n    response.code = 401;\n    response.setError('auth', 'Unauthorized');\n  }\n};\n\nexport const requirements = {\n  get: {\n    before: [authMiddleware]\n  },\n  put: {\n    requiredBody: 'UpdateUserRequest',\n    before: [authMiddleware],\n    timeout: 5000\n  },\n  delete: {\n    before: [authMiddleware]\n  }\n};\n\nexport const get = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n  const user = await getUserById(request.pathParameters.id);\n  if (!user) {\n    response.code = 404;\n    response.setError('user', 'User not found');\n    return response;\n  }\n  response.body = user;\n  return response;\n};\n\nexport const put = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n  const user = await updateUser(request.pathParameters.id, request.body);\n  response.body = user;\n  return response;\n};\n\nexport const delete = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n  await deleteUser(request.pathParameters.id);\n  response.code = 204;\n  return response;\n};\n</code></pre>"},{"location":"usage/functional/#router-configuration","title":"\ud83c\udf10 Router Configuration","text":"<p>Configure your router to work with functional patterns:</p> <pre><code>import { Router } from 'acai-ts';\nimport { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\n\nconst router = new Router({\n  basePath: '/api/v1',\n  routesPath: './src/handlers/**/*.ts',  // File-based routing\n  schemaPath: './openapi.yml',           // Optional: OpenAPI validation\n  timeout: 30000,                        // Default timeout\n  outputError: true,\n  globalLogger: true,\n  withAuth: async (request, response) =&gt; { // Global auth middleware\n    const token = request.headers.authorization?.replace('Bearer ', '');\n    if (!token || !validateJWT(token)) {\n      response.code = 401;\n      response.setError('auth', 'Invalid or missing authentication token');\n    }\n  }\n});\n\nexport const handler = async (\n  event: APIGatewayProxyEvent\n): Promise&lt;APIGatewayProxyResult&gt; =&gt; {\n  return await router.route(event);\n};\n</code></pre>"},{"location":"usage/functional/#middleware-execution-order","title":"\ud83d\udd04 Middleware Execution Order","text":"<p>When using the functional pattern, middleware executes in this order:</p> <ol> <li>Global middleware (router-level <code>beforeAll</code>)</li> <li>Auth middleware (router's <code>withAuth</code> if <code>auth: true</code>)</li> <li>Before middleware (from requirements object)</li> <li>Validation (schema validation)</li> <li>Handler function (your get/post/put/delete function)</li> <li>After middleware (from requirements object)</li> <li>Global after middleware (router-level <code>afterAll</code>)</li> </ol> <pre><code>export const requirements = {\n  post: {\n    auth: true,                    // 2. Auth middleware\n    before: [middleware1, middleware2], // 3. Before middleware (in order)\n    requiredBody: 'UserSchema',    // 4. Validation\n    after: [middleware3]           // 6. After middleware\n    // 5. Handler function runs between before/after\n  }\n};\n</code></pre>"},{"location":"usage/functional/#best-practices","title":"\ud83c\udf1f Best Practices","text":""},{"location":"usage/functional/#1-organize-middleware","title":"1\ufe0f\u20e3 Organize Middleware","text":"<pre><code>// Create a middleware directory\n// middleware/auth.ts\nexport const authMiddleware = async (request: Request, response: Response) =&gt; {\n  // Auth logic\n};\n\n// middleware/logging.ts\nexport const logRequest = async (request: Request, response: Response) =&gt; {\n  // Logging logic\n};\n\n// Import in handlers\nimport { authMiddleware } from '../middleware/auth';\nimport { logRequest } from '../middleware/logging';\n</code></pre>"},{"location":"usage/functional/#2-reuse-requirements","title":"2\ufe0f\u20e3 Reuse Requirements","text":"<pre><code>// common/requirements.ts\nexport const authRequired = {\n  before: [authMiddleware],\n  auth: true\n};\n\nexport const adminRequired = {\n  ...authRequired,\n  before: [...authRequired.before, adminCheckMiddleware]\n};\n\n// In handler files\nimport { authRequired, adminRequired } from '../common/requirements';\n\nexport const requirements = {\n  get: authRequired,\n  post: adminRequired\n};\n</code></pre>"},{"location":"usage/functional/#3-type-safety","title":"3\ufe0f\u20e3 Type Safety","text":"<pre><code>interface CreateUserRequest {\n  name: string;\n  email: string;\n}\n\nexport const post = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n  // Type assertion for better TypeScript support\n  const userData = request.body as CreateUserRequest;\n\n  const user = await createUser(userData);\n  response.body = user;\n  return response;\n};\n</code></pre>"},{"location":"usage/functional/#4-error-handling","title":"4\ufe0f\u20e3 Error Handling","text":"<pre><code>export const get = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n  try {\n    const users = await getUserList();\n    response.body = { users };\n  } catch (error) {\n    response.code = 500;\n    response.setError('server', 'Failed to fetch users');\n  }\n  return response;\n};\n</code></pre>"},{"location":"usage/functional/#functional-vs-decorator-patterns","title":"\u2696\ufe0f Functional vs Decorator Patterns","text":""},{"location":"usage/functional/#when-to-use-functional-pattern","title":"\ud83d\udd27 When to Use Functional Pattern","text":"<ul> <li>\u2705 Prefer configuration over decorators</li> <li>\u2705 Want to reuse middleware configurations</li> <li>\u2705 Working with existing JavaScript codebases</li> <li>\u2705 Team prefers explicit configuration objects</li> <li>\u2705 Need runtime configuration changes</li> </ul>"},{"location":"usage/functional/#when-to-use-decorator-pattern","title":"\ud83c\udfa8 When to Use Decorator Pattern","text":"<ul> <li>\u2705 Love declarative, annotation-style code</li> <li>\u2705 Want method-level configuration</li> <li>\u2705 Working in pure TypeScript environments</li> <li>\u2705 Prefer co-located configuration with methods</li> </ul>"},{"location":"usage/functional/#migration-between-patterns","title":"\ud83d\udd04 Migration Between Patterns","text":"<p>From Functional to Decorators: <pre><code>// Before (Functional)\nexport const requirements = {\n  post: {\n    auth: true,\n    requiredBody: 'CreateUserRequest',\n    before: [logRequest],\n    timeout: 5000\n  }\n};\n\nexport const post = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n  // Handler code\n};\n\n// After (Decorators)\nexport class UsersEndpoint extends BaseEndpoint {\n  @Auth()\n  @Validate({ requiredBody: 'CreateUserRequest' })\n  @Before(logRequest)\n  @Timeout(5000)\n  async post(request: Request, response: Response): Promise&lt;Response&gt; {\n    // Same handler code\n  }\n}\n</code></pre></p>"},{"location":"usage/functional/#common-patterns","title":"\ud83d\udce6 Common Patterns","text":""},{"location":"usage/functional/#crud-operations","title":"\ud83d\udcdd CRUD Operations","text":"<pre><code>// File: src/handlers/posts.ts\nconst authAndLog = [authMiddleware, logRequest];\n\nexport const requirements = {\n  get: {\n    before: [logRequest],\n    after: [addTimestamp]\n  },\n  post: {\n    requiredBody: 'CreatePostRequest',\n    before: authAndLog,\n    after: [addTimestamp],\n    timeout: 5000\n  },\n  put: {\n    requiredBody: 'UpdatePostRequest', \n    before: authAndLog,\n    timeout: 5000\n  },\n  delete: {\n    before: authAndLog\n  }\n};\n\nexport const get = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n  const posts = await getPostList();\n  response.body = { posts };\n  return response;\n};\n\nexport const post = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n  const post = await createPost(request.body);\n  response.code = 201;\n  response.body = post;\n  return response;\n};\n\nexport const put = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n  const post = await updatePost(request.body);\n  response.body = post;\n  return response;\n};\n\nexport const delete = async (request: Request, response: Response): Promise&lt;Response&gt; =&gt; {\n  await deletePost(request.pathParameters.id);\n  response.code = 204;\n  return response;\n};\n</code></pre>"},{"location":"usage/functional/#api-versioning","title":"\ud83d\udd22 API Versioning","text":"<pre><code>// File: src/handlers/v1/users.ts\nexport const requirements = {\n  get: { before: [logRequest] }\n};\n\n// File: src/handlers/v2/users.ts  \nexport const requirements = {\n  get: { \n    before: [logRequest, newValidationMiddleware],\n    requiredQuery: ['version']\n  }\n};\n</code></pre> <p>For more examples and advanced patterns, see our decorator documentation and troubleshooting guide.</p>"}]}